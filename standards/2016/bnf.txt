<Ada BINARY variable> ::=
    SQL TYPE IS BINARY <left paren> <length> <right paren>

<Ada BLOB locator variable> ::=
    SQL TYPE IS BLOB AS LOCATOR

<Ada BLOB variable> ::=
    SQL TYPE IS BLOB <left paren> <large object length> <right paren>

<Ada CLOB locator variable> ::=
    SQL TYPE IS CLOB AS LOCATOR

<Ada CLOB variable> ::=
    SQL TYPE IS CLOB <left paren> <character large object length> <right paren> 
    [ CHARACTER SET [ IS ] <character set specification> ]

<Ada REF variable> ::=
    SQL TYPE IS <reference type>

<Ada VARBINARY variable> ::=
    SQL TYPE IS VARBINARY <left paren> <length> <right paren>

<Ada array locator variable> ::=
    SQL TYPE IS <array type> AS LOCATOR

<Ada assignment operator> ::=
    <colon> <equals operator>

<Ada derived type specification> ::=
    <Ada CLOB variable>
  | <Ada CLOB locator variable>
  | <Ada BINARY variable>
  | <Ada VARBINARY variable>
  | <Ada BLOB variable>
  | <Ada BLOB locator variable>
  | <Ada user-defined type variable>
  | <Ada user-defined type locator variable>
  | <Ada REF variable>
  | <Ada array locator variable>
  | <Ada multiset locator variable>

<Ada host identifier> ::=
    !! See the Syntax Rules.

<Ada initial value> ::=
    <Ada assignment operator> <character representation>...

<Ada multiset locator variable> ::=
    SQL TYPE IS <multiset type> AS LOCATOR

<Ada qualified type specification> ::=
    Interfaces.SQL.CHAR [ CHARACTER SET [ IS ] <character set specification> ] 
    <left paren> 1 <double period> <character length> <right paren>
  | Interfaces.SQL.SMALLINT
  | Interfaces.SQL.INT
  | Interfaces.SQL.BIGINT
  | Interfaces.SQL.REAL
  | Interfaces.SQL.DOUBLE_PRECISION
  | Interfaces.SQL.BOOLEAN
  | Interfaces.SQL.SQLSTATE_TYPE
  | Interfaces.SQL.INDICATOR_TYPE

<Ada type specification> ::=
    <Ada qualified type specification>
  | <Ada unqualified type specification>
  | <Ada derived type specification>

<Ada unqualified type specification> ::=
    CHAR <left paren> 1 <double period> <character length> <right paren>
  | SMALLINT
  | INT
  | BIGINT
  | REAL
  | DOUBLE_PRECISION
  | BOOLEAN
  | SQLSTATE_TYPE
  | INDICATOR_TYPE

<Ada user-defined type locator variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR

<Ada user-defined type variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>

<Ada variable definition> ::=
    <Ada host identifier> [ { <comma> <Ada host identifier> }... ] <colon> 
    <Ada type specification> [ <Ada initial value> ]

<C BINARY variable> ::=
    SQL TYPE IS BINARY <left paren> <length> <right paren> <C host identifier> 
    [ <C initial value> ] 
    [ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C BLOB locator variable> ::=
    SQL TYPE IS BLOB AS LOCATOR <C host identifier> [ <C initial value> ] 
    [ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C BLOB variable> ::=
    SQL TYPE IS BLOB <left paren> <large object length> <right paren> 
    <C host identifier> [ <C initial value> ] 
    [ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C CLOB locator variable> ::=
    SQL TYPE IS CLOB AS LOCATOR <C host identifier> [ <C initial value> ] 
    [ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C CLOB variable> ::=
    SQL TYPE IS CLOB <left paren> <character large object length> <right paren> 
    [ CHARACTER SET [ IS ] <character set specification> ] <C host identifier> 
    [ <C initial value> ] 
    [ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C NCHAR VARYING variable> ::=
    NCHAR VARYING <C host identifier> <C array specification> 
    [ <C initial value> ] 
    [ { <comma> <C host identifier> <C array specification> [ <C initial value> ] }... ]

<C NCHAR variable> ::=
    NCHAR <C host identifier> <C array specification> [ <C initial value> ] 
    [ { <comma> <C host identifier> <C array specification> [ <C initial value> ] }... ]

<C NCLOB variable> ::=
    SQL TYPE IS NCLOB <left paren> <character large object length> <right paren> 
    <C host identifier> [ <C initial value> ] 
    [ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C REF variable> ::=
    SQL TYPE IS <reference type> <C host identifier> [ <C initial value> ] 
    [ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C VARBINARY variable> ::=
    SQL TYPE IS VARBINARY <left paren> <length> <right paren> <C host identifier> 
    [ <C initial value> ] 
    [ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C VARCHAR variable> ::=
    VARCHAR [ CHARACTER SET [ IS ] <character set specification> ] 
    <C host identifier> <C array specification> [ <C initial value> ] 
    [ { <comma> <C host identifier> <C array specification> [ <C initial value> ] }... ]

<C array locator variable> ::=
    SQL TYPE IS <array type> AS LOCATOR <C host identifier> [ <C initial value> ] 
    [ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C array specification> ::=
    <left bracket> <character length> <right bracket>

<C character type> ::=
    char
  | unsigned char
  | unsigned short

<C character variable> ::=
    <C character type> [ CHARACTER SET [ IS ] <character set specification> ] 
    <C host identifier> <C array specification> [ <C initial value> ] 
    [ { <comma> <C host identifier> <C array specification> [ <C initial value> ] }... ]

<C class modifier> ::=
    const
  | volatile

<C derived variable> ::=
    <C VARCHAR variable>
  | <C NCHAR variable>
  | <C NCHAR VARYING variable>
  | <C CLOB variable>
  | <C NCLOB variable>
  | <C BINARY variable>
  | <C VARBINARY variable>
  | <C BLOB variable>
  | <C user-defined type variable>
  | <C CLOB locator variable>
  | <C BLOB locator variable>
  | <C array locator variable>
  | <C multiset locator variable>
  | <C user-defined type locator variable>
  | <C REF variable>

<C host identifier> ::=
    !! See the Syntax Rules.

<C initial value> ::=
    <equals operator> <character representation>...

<C multiset locator variable> ::=
    SQL TYPE IS <multiset type> AS LOCATOR <C host identifier> 
    [ <C initial value> ] 
    [ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C numeric variable> ::=
    { long long long short float double } <C host identifier> 
    [ <C initial value> ] 
    [ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C storage class> ::=
    auto
  | extern
  | static

<C user-defined type locator variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR 
    <C host identifier> [ <C initial value> ] 
    [ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C user-defined type variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS <predefined type> 
    <C host identifier> [ <C initial value> ] 
    [ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C variable definition> ::=
    [ <C storage class> ] [ <C class modifier> ] <C variable specification> 
    <semicolon>

<C variable specification> ::=
    <C numeric variable>
  | <C character variable>
  | <C derived variable>

<COBOL BINARY variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS BINARY <left paren> <length> <right paren>

<COBOL BLOB locator variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS BLOB AS LOCATOR

<COBOL BLOB variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS BLOB <left paren> <large object length> 
    <right paren>

<COBOL CLOB locator variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS CLOB AS LOCATOR

<COBOL CLOB variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS CLOB <left paren> <character large object length> 
    <right paren> [ CHARACTER SET [ IS ] <character set specification> ]

<COBOL NCLOB variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS NCLOB <left paren> 
    <character large object length> <right paren>

<COBOL REF variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS <reference type>

<COBOL array locator variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS <array type> AS LOCATOR

<COBOL character type> ::=
    [ CHARACTER SET [ IS ] <character set specification> ] { PIC PICTURE } [ IS ] 
    { X [ <left paren> <character length> <right paren> ] }...

<COBOL derived type specification> ::=
    <COBOL CLOB variable>
  | <COBOL NCLOB variable>
  | <COBOL BINARY variable>
  | <COBOL BLOB variable>
  | <COBOL user-defined type variable>
  | <COBOL CLOB locator variable>
  | <COBOL BLOB locator variable>
  | <COBOL array locator variable>
  | <COBOL multiset locator variable>
  | <COBOL user-defined type locator variable>
  | <COBOL REF variable>

<COBOL host identifier> ::=
    !! See the Syntax Rules.

<COBOL integer type> ::=
    { PIC PICTURE } [ IS ] S <COBOL nines> [ USAGE [ IS ] ] BINARY

<COBOL multiset locator variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS <multiset type> AS LOCATOR

<COBOL national character type> ::=
    { PIC PICTURE } [ IS ] 
    { N [ <left paren> <character length> <right paren> ] }...

<COBOL nines> ::=
    { 9 [ <left paren> <length> <right paren> ] }...

<COBOL nines specification> ::=
    <COBOL nines> [ V [ <COBOL nines> ] ]
  | V <COBOL nines>

<COBOL numeric type> ::=
    { PIC PICTURE } [ IS ] S <COBOL nines specification> [ USAGE [ IS ] ] DISPLAY 
    SIGN LEADING SEPARATE

<COBOL type specification> ::=
    <COBOL character type>
  | <COBOL national character type>
  | <COBOL numeric type>
  | <COBOL integer type>
  | <COBOL derived type specification>

<COBOL user-defined type locator variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR

<COBOL user-defined type variable> ::=
    [ USAGE [ IS ] ] SQL TYPE IS <path-resolved user-defined type name> AS 
    <predefined type>

<COBOL variable definition> ::=
    { 01 77 } <COBOL host identifier> <COBOL type specification> 
    [ <character representation>... ] <period>

<Fortran BINARY variable> ::=
    SQL TYPE IS BINARY <left paren> <length> <right paren>

<Fortran BLOB locator variable> ::=
    SQL TYPE IS BLOB AS LOCATOR

<Fortran BLOB variable> ::=
    SQL TYPE IS BLOB <left paren> <large object length> <right paren>

<Fortran CLOB locator variable> ::=
    SQL TYPE IS CLOB AS LOCATOR

<Fortran CLOB variable> ::=
    SQL TYPE IS CLOB <left paren> <character large object length> <right paren> 
    [ CHARACTER SET [ IS ] <character set specification> ]

<Fortran REF variable> ::=
    SQL TYPE IS <reference type>

<Fortran VARBINARY variable> ::=
    SQL TYPE IS VARBINARY <left paren> <length> <right paren>

<Fortran array locator variable> ::=
    SQL TYPE IS <array type> AS LOCATOR

<Fortran derived type specification> ::=
    <Fortran CLOB variable>
  | <Fortran BINARY variable>
  | <Fortran VARBINARY variable>
  | <Fortran BLOB variable>
  | <Fortran user-defined type variable>
  | <Fortran CLOB locator variable>
  | <Fortran BLOB locator variable>
  | <Fortran user-defined type locator variable>
  | <Fortran array locator variable>
  | <Fortran multiset locator variable>
  | <Fortran REF variable>

<Fortran host identifier> ::=
    !! See the Syntax Rules.

<Fortran multiset locator variable> ::=
    SQL TYPE IS <multiset type> AS LOCATOR

<Fortran type specification> ::=
    CHARACTER [ <asterisk> <character length> ] 
    [ CHARACTER SET [ IS ] <character set specification> ]
  | CHARACTER KIND = n [ <asterisk> <character length> ] 
    [ CHARACTER SET [ IS ] <character set specification> ]
  | INTEGER
  | REAL
  | DOUBLE PRECISION
  | LOGICAL
  | <Fortran derived type specification>

<Fortran user-defined type locator variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR

<Fortran user-defined type variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>

<Fortran variable definition> ::=
    <Fortran type specification> <Fortran host identifier> 
    [ { <comma> <Fortran host identifier> }... ]

<JSON API common syntax> ::=
    <JSON context item> <comma> <JSON path specification> 
    [ AS <JSON table path name> ] [ <JSON passing clause> ]

<JSON aggregate function> ::=
    <JSON object aggregate constructor>
  | <JSON array aggregate constructor>

<JSON argument> ::=
    <JSON value expression> AS <identifier>

<JSON array aggregate constructor> ::=
    JSON_ARRAYAGG <left paren> <JSON value expression> 
    [ <JSON array aggregate order by clause> ] 
    [ <JSON constructor null clause> ] [ <JSON output clause> ] <right paren>

<JSON array aggregate order by clause> ::=
    ORDER BY <sort specification list>

<JSON array constructor> ::=
    <JSON array constructor by enumeration>
  | <JSON array constructor by query>

<JSON array constructor by enumeration> ::=
    JSON_ARRAY <left paren> 
    [ <JSON value expression> [ { <comma> <JSON value expression> }... ] [ <JSON constructor null clause> ] ] 
    [ <JSON output clause> ] <right paren>

<JSON array constructor by query> ::=
    JSON_ARRAY <left paren> <query expression> [ <JSON input clause> ] 
    [ <JSON constructor null clause> ] [ <JSON output clause> ] <right paren>

<JSON constructor null clause> ::=
    NULL ON NULL
  | ABSENT ON NULL

<JSON context item> ::=
    <JSON value expression>

<JSON exists error behavior> ::=
    TRUE
  | FALSE
  | UNKNOWN
  | ERROR

<JSON exists predicate> ::=
    JSON_EXISTS <left paren> <JSON API common syntax> 
    [ <JSON exists error behavior> ON ERROR ] <right paren>

<JSON input clause> ::=
    FORMAT <JSON representation>

<JSON key uniqueness constraint> ::=
    WITH UNIQUE [ KEYS ]
  | WITHOUT UNIQUE [ KEYS ]

<JSON name> ::=
    <character value expression>

<JSON name and value> ::=
    [ KEY ] <JSON name> VALUE <JSON value expression>
  | <JSON name> <colon> <JSON value expression>

<JSON object aggregate constructor> ::=
    JSON_OBJECTAGG <left paren> <JSON name and value> 
    [ <JSON constructor null clause> ] [ <JSON key uniqueness constraint> ] 
    [ <JSON output clause> ] <right paren>

<JSON object constructor> ::=
    JSON_OBJECT <left paren> 
    [ <JSON name and value> [ { <comma> <JSON name and value> }... ] [ <JSON constructor null clause> ] [ <JSON key uniqueness constraint> ] ] 
    [ <JSON output clause> ] <right paren>

<JSON output clause> ::=
    RETURNING <data type> [ FORMAT <JSON representation> ]

<JSON passing clause> ::=
    PASSING <JSON argument> [ { <comma> <JSON argument> }... ]

<JSON path specification> ::=
    <character string literal>

<JSON predicate> ::=
    <string value expression> [ <JSON input clause> ] IS [ NOT ] JSON 
    [ <JSON predicate type constraint> ] [ <JSON key uniqueness constraint> ]

<JSON predicate type constraint> ::=
    VALUE
  | ARRAY
  | OBJECT
  | SCALAR

<JSON query> ::=
    JSON_QUERY <left paren> <JSON API common syntax> [ <JSON output clause> ] 
    [ <JSON query wrapper behavior> WRAPPER ] 
    [ <JSON query quotes behavior> QUOTES [ ON SCALAR STRING ] ] 
    [ <JSON query empty behavior> ON EMPTY ] 
    [ <JSON query error behavior> ON ERROR ] <right paren>

<JSON query empty behavior> ::=
    ERROR
  | NULL
  | EMPTY ARRAY
  | EMPTY OBJECT

<JSON query error behavior> ::=
    ERROR
  | NULL
  | EMPTY ARRAY
  | EMPTY OBJECT

<JSON query quotes behavior> ::=
    KEEP
  | OMIT

<JSON query wrapper behavior> ::=
    WITHOUT [ ARRAY ]
  | WITH [ CONDITIONAL UNCONDITIONAL ] [ ARRAY ]

<JSON representation> ::=
    JSON [ ENCODING { UTF8 UTF16 UTF32 } ]
  | <implementation-defined JSON representation option>

<JSON returning clause> ::=
    RETURNING <data type>

<JSON table> ::=
    JSON_TABLE <left paren> <JSON API common syntax> <JSON table columns clause> 
    [ <JSON table plan clause> ] [ <JSON table error behavior> ON ERROR ] 
    <right paren>

<JSON table column definition> ::=
    <JSON table ordinality column definition>
  | <JSON table regular column definition>
  | <JSON table formatted column definition>
  | <JSON table nested columns>

<JSON table column empty behavior> ::=
    ERROR
  | NULL
  | DEFAULT <value expression>

<JSON table column error behavior> ::=
    ERROR
  | NULL
  | DEFAULT <value expression>

<JSON table column path specification> ::=
    <JSON path specification>

<JSON table columns clause> ::=
    COLUMNS <left paren> <JSON table column definition> 
    [ { <comma> <JSON table column definition> }... ] <right paren>

<JSON table default plan> ::=
    PLAN DEFAULT <left paren> <JSON table default plan choices> <right paren>

<JSON table default plan choices> ::=
    <JSON table default plan inner/outer> 
    [ <comma> <JSON table default plan union/cross> ]
  | <JSON table default plan union/cross> 
    [ <comma> <JSON table default plan inner/outer> ]

<JSON table default plan inner/outer> ::=
    INNER
  | OUTER

<JSON table default plan union/cross> ::=
    UNION
  | CROSS

<JSON table error behavior> ::=
    ERROR
  | EMPTY

<JSON table formatted column definition> ::=
    <column name> <data type> FORMAT <JSON representation> 
    [ PATH <JSON table column path specification> ] 
    [ <JSON table formatted column wrapper behavior> WRAPPER ] 
    [ <JSON table formatted column quotes behavior> QUOTES [ ON SCALAR STRING ] ] 
    [ <JSON table formatted column empty behavior> ON EMPTY ] 
    [ <JSON table formatted column error behavior> ON ERROR ]

<JSON table formatted column empty behavior> ::=
    ERROR
  | NULL
  | EMPTY ARRAY
  | EMPTY OBJECT

<JSON table formatted column error behavior> ::=
    ERROR
  | NULL
  | EMPTY ARRAY
  | EMPTY OBJECT

<JSON table formatted column quotes behavior> ::=
    KEEP
  | OMIT

<JSON table formatted column wrapper behavior> ::=
    WITHOUT [ ARRAY ]
  | WITH [ CONDITIONAL UNCONDITIONAL ] [ ARRAY ]

<JSON table nested columns> ::=
    NESTED [ PATH ] <JSON table nested path specification> 
    [ AS <JSON table nested path name> ] <JSON table columns clause>

<JSON table nested path name> ::=
    <JSON table path name>

<JSON table nested path specification> ::=
    <JSON path specification>

<JSON table ordinality column definition> ::=
    <column name> FOR ORDINALITY

<JSON table path name> ::=
    <identifier>

<JSON table plan> ::=
    <JSON table path name>
  | <JSON table plan parent/child>
  | <JSON table plan sibling>

<JSON table plan clause> ::=
    <JSON table specific plan>
  | <JSON table default plan>

<JSON table plan cross> ::=
    <JSON table plan primary> CROSS <JSON table plan primary> 
    [ { CROSS <JSON table plan primary> }... ]

<JSON table plan inner> ::=
    <JSON table path name> INNER <JSON table plan primary>

<JSON table plan outer> ::=
    <JSON table path name> OUTER <JSON table plan primary>

<JSON table plan parent/child> ::=
    <JSON table plan outer>
  | <JSON table plan inner>

<JSON table plan primary> ::=
    <JSON table path name>
  | <left paren> <JSON table plan> <right paren>

<JSON table plan sibling> ::=
    <JSON table plan union>
  | <JSON table plan cross>

<JSON table plan union> ::=
    <JSON table plan primary> UNION <JSON table plan primary> 
    [ { UNION <JSON table plan primary> }... ]

<JSON table primitive> ::=
    JSON_TABLE_PRIMITIVE <left paren> <JSON API common syntax> 
    <JSON table primitive columns clause> <JSON table error behavior> ON ERROR 
    <right paren>

<JSON table primitive chaining column> ::=
    <column name> FOR CHAINING

<JSON table primitive column definition> ::=
    <JSON table ordinality column definition>
  | <JSON table regular column definition>
  | <JSON table formatted column definition>
  | <JSON table primitive chaining column>

<JSON table primitive columns clause> ::=
    COLUMNS <left paren> <JSON table primitive column definition> 
    [ { <comma> <JSON table primitive column definition> }... ] <right paren>

<JSON table regular column definition> ::=
    <column name> <data type> [ PATH <JSON table column path specification> ] 
    [ <JSON table column empty behavior> ON EMPTY ] 
    [ <JSON table column error behavior> ON ERROR ]

<JSON table specific plan> ::=
    PLAN <left paren> <JSON table plan> <right paren>

<JSON value constructor> ::=
    <JSON object constructor>
  | <JSON array constructor>

<JSON value empty behavior> ::=
    ERROR
  | NULL
  | DEFAULT <value expression>

<JSON value error behavior> ::=
    ERROR
  | NULL
  | DEFAULT <value expression>

<JSON value expression> ::=
    <value expression> [ <JSON input clause> ]

<JSON value function> ::=
    JSON_VALUE <left paren> <JSON API common syntax> [ <JSON returning clause> ] 
    [ <JSON value empty behavior> ON EMPTY ] 
    [ <JSON value error behavior> ON ERROR ] <right paren>

<MUMPS BLOB locator variable> ::=
    SQL TYPE IS BLOB AS LOCATOR

<MUMPS CLOB locator variable> ::=
    SQL TYPE IS CLOB AS LOCATOR

<MUMPS REF variable> ::=
    SQL TYPE IS <reference type>

<MUMPS array locator variable> ::=
    SQL TYPE IS <array type> AS LOCATOR

<MUMPS character variable> ::=
    VARCHAR <MUMPS character variable specifier> 
    [ { <comma> <MUMPS character variable specifier> }... ]

<MUMPS character variable specifier> ::=
    <MUMPS host identifier> <MUMPS length specification> 
    [ CHARACTER SET [ IS ] <character set specification> ]

<MUMPS derived type specification> ::=
    <MUMPS user-defined type variable>
  | <MUMPS CLOB locator variable>
  | <MUMPS BLOB locator variable>
  | <MUMPS user-defined type locator variable>
  | <MUMPS array locator variable>
  | <MUMPS multiset locator variable>
  | <MUMPS REF variable>

<MUMPS host identifier> ::=
    

<MUMPS length specification> ::=
    <left paren> <character length> <right paren>

<MUMPS multiset locator variable> ::=
    SQL TYPE IS <multiset type> AS LOCATOR

<MUMPS numeric variable> ::=
    <MUMPS type specification> <MUMPS host identifier> 
    [ { <comma> <MUMPS host identifier> }... ]

<MUMPS type specification> ::=
    INT
  | DEC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  | REAL

<MUMPS user-defined type locator variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR

<MUMPS user-defined type variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>

<MUMPS variable definition> ::=
    <MUMPS numeric variable> <semicolon>
  | <MUMPS character variable> <semicolon>
  | <MUMPS derived type specification> <MUMPS host identifier> <semicolon>

<PL/I BINARY variable> ::=
    SQL TYPE IS BINARY <left paren> <length> <right paren>

<PL/I BLOB locator variable> ::=
    SQL TYPE IS BLOB AS LOCATOR

<PL/I BLOB variable> ::=
    SQL TYPE IS BLOB <left paren> <large object length> <right paren>

<PL/I CLOB locator variable> ::=
    SQL TYPE IS CLOB AS LOCATOR

<PL/I CLOB variable> ::=
    SQL TYPE IS CLOB <left paren> <character large object length> <right paren> 
    [ CHARACTER SET [ IS ] <character set specification> ]

<PL/I REF variable> ::=
    SQL TYPE IS <reference type>

<PL/I VARBINARY variable> ::=
    SQL TYPE IS VARBINARY <left paren> <length> <right paren>

<PL/I array locator variable> ::=
    SQL TYPE IS <array type> AS LOCATOR

<PL/I derived type specification> ::=
    <PL/I CLOB variable>
  | <PL/I BINARY variable>
  | <PL/I VARBINARY variable>
  | <PL/I BLOB variable>
  | <PL/I user-defined type variable>
  | <PL/I CLOB locator variable>
  | <PL/I BLOB locator variable>
  | <PL/I user-defined type locator variable>
  | <PL/I array locator variable>
  | <PL/I multiset locator variable>
  | <PL/I REF variable>

<PL/I host identifier> ::=
    !! See the Syntax Rules.

<PL/I multiset locator variable> ::=
    SQL TYPE IS <multiset type> AS LOCATOR

<PL/I type fixed binary> ::=
    { BIN BINARY } FIXED
  | FIXED { BIN BINARY }

<PL/I type fixed decimal> ::=
    { DEC DECIMAL } FIXED
  | FIXED { DEC DECIMAL }

<PL/I type float binary> ::=
    { BIN BINARY } FLOAT
  | FLOAT { BIN BINARY }

<PL/I type specification> ::=
    { CHAR CHARACTER } [ VARYING ] <left paren> <character length> <right paren> 
    [ CHARACTER SET [ IS ] <character set specification> ]
  | <PL/I type fixed decimal> <left paren> <precision> [ <comma> <scale> ] 
    <right paren>
  | <PL/I type fixed binary> [ <left paren> <precision> <right paren> ]
  | <PL/I type float binary> <left paren> <precision> <right paren>
  | <PL/I derived type specification>

<PL/I user-defined type locator variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR

<PL/I user-defined type variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>

<PL/I variable definition> ::=
    { DCL DECLARE } <PL/I type specification> [ <character representation>... ] 
    <semicolon>
  | { <PL/I host identifier> <left paren> <PL/I host identifier> [ { <comma> <PL/I host identifier> }... ] <right paren> } 
    <PL/I type specification> [ <character representation>... ] <semicolon>

<PTF cursor name> ::=
    PTF <simple value specification>

<PTF derived table> ::=
    TABLE <left paren> <routine invocation> <right paren>

<PTF describe component procedure> ::=
    <specific routine designator>

<PTF descriptor name> ::=
    PTF <simple value specification>

<PTF finish component procedure> ::=
    <specific routine designator>

<PTF fulfill component procedure> ::=
    <specific routine designator>

<PTF private parameters> ::=
    PRIVATE [ DATA ] <private parameter declaration list>

<PTF start component procedure> ::=
    <specific routine designator>

<Pascal BINARY variable> ::=
    SQL TYPE IS BINARY <left paren> <length> <right paren>

<Pascal BLOB locator variable> ::=
    SQL TYPE IS BLOB AS LOCATOR

<Pascal BLOB variable> ::=
    SQL TYPE IS BLOB <left paren> <large object length> <right paren>

<Pascal CLOB locator variable> ::=
    SQL TYPE IS CLOB AS LOCATOR

<Pascal CLOB variable> ::=
    SQL TYPE IS CLOB <left paren> <character large object length> <right paren> 
    [ CHARACTER SET [ IS ] <character set specification> ]

<Pascal REF variable> ::=
    SQL TYPE IS <reference type>

<Pascal array locator variable> ::=
    SQL TYPE IS <array type> AS LOCATOR

<Pascal derived type specification> ::=
    <Pascal CLOB variable>
  | <Pascal BINARY variable>
  | <Pascal BLOB variable>
  | <Pascal user-defined type variable>
  | <Pascal CLOB locator variable>
  | <Pascal BLOB locator variable>
  | <Pascal user-defined type locator variable>
  | <Pascal array locator variable>
  | <Pascal multiset locator variable>
  | <Pascal REF variable>

<Pascal host identifier> ::=
    !! See the Syntax Rules.

<Pascal multiset locator variable> ::=
    SQL TYPE IS <multiset type> AS LOCATOR

<Pascal type specification> ::=
    PACKED ARRAY <left bracket> 1 <double period> <character length> 
    <right bracket> OF CHAR 
    [ CHARACTER SET [ IS ] <character set specification> ]
  | INTEGER
  | REAL
  | CHAR [ CHARACTER SET [ IS ] <character set specification> ]
  | BOOLEAN
  | <Pascal derived type specification>

<Pascal user-defined type locator variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR

<Pascal user-defined type variable> ::=
    SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>

<Pascal variable definition> ::=
    <Pascal host identifier> [ { <comma> <Pascal host identifier> }... ] <colon> 
    <Pascal type specification> <semicolon>

<SQL argument> ::=
    <value expression>
  | <generalized expression>
  | <target specification>
  | <contextually typed value specification>
  | <named argument specification>
  | <table argument>
  | <descriptor argument>

<SQL argument list> ::=
    <left paren> 
    [ <SQL argument> [ { <comma> <SQL argument> }... ] [ <copartition clause> ] ] 
    <right paren>

<SQL condition> ::=
    <major category>
  | SQLSTATE ( <SQLSTATE class code> [ , <SQLSTATE subclass code> ] )
  | CONSTRAINT <constraint name>

<SQL connection statement> ::=
    <connect statement>
  | <set connection statement>
  | <disconnect statement>

<SQL control statement> ::=
    <call statement>
  | <return statement>

<SQL data change statement> ::=
    <delete statement: positioned>
  | <delete statement: searched>
  | <insert statement>
  | <update statement: positioned>
  | <update statement: searched>
  | <truncate table statement>
  | <merge statement>

<SQL data statement> ::=
    <open statement>
  | <fetch statement>
  | <close statement>
  | <select statement: single row>
  | <free locator statement>
  | <hold locator statement>
  | <SQL data change statement>

<SQL descriptor statement> ::=
    <allocate descriptor statement>
  | <deallocate descriptor statement>
  | <set descriptor statement>
  | <get descriptor statement>

<SQL diagnostics information> ::=
    <statement information>
  | <condition information>
  | <all information>

<SQL diagnostics statement> ::=
    <get diagnostics statement>

<SQL dynamic data statement> ::=
    <allocate extended dynamic cursor statement>
  | <allocate received cursor statement>
  | <dynamic open statement>
  | <dynamic fetch statement>
  | <dynamic close statement>
  | <dynamic delete statement: positioned>
  | <dynamic update statement: positioned>

<SQL dynamic statement> ::=
    <SQL descriptor statement>
  | <prepare statement>
  | <deallocate prepared statement>
  | <describe statement>
  | <execute statement>
  | <execute immediate statement>
  | <SQL dynamic data statement>
  | <copy descriptor statement>
  | <pipe row statement>

<SQL executable statement> ::=
    <SQL schema statement>
  | <SQL data statement>
  | <SQL control statement>
  | <SQL transaction statement>
  | <SQL connection statement>
  | <SQL session statement>
  | <SQL diagnostics statement>
  | <SQL dynamic statement>

<SQL language character> ::=
    <simple Latin letter>
  | <digit>
  | <SQL special character>

<SQL language identifier> ::=
    <SQL language identifier start> [ <SQL language identifier part>... ]

<SQL language identifier part> ::=
    <simple Latin letter>
  | <digit>
  | <underscore>

<SQL language identifier start> ::=
    <simple Latin letter>

<SQL parameter declaration> ::=
    [ <parameter mode> ] [ <SQL parameter name> ] <parameter type> [ RESULT ] 
    [ DEFAULT <parameter default> ]

<SQL parameter declaration list> ::=
    <left paren> 
    [ <SQL parameter declaration> [ { <comma> <SQL parameter declaration> }... ] ] 
    <right paren>

<SQL parameter name> ::=
    <identifier>

<SQL parameter reference> ::=
    <basic identifier chain>

<SQL prefix> ::=
    EXEC SQL
  | <ampersand> SQL <left paren>

<SQL procedure statement> ::=
    <SQL executable statement>

<SQL routine body> ::=
    <SQL procedure statement>

<SQL routine spec> ::=
    [ <rights clause> ] <SQL routine body>

<SQL schema definition statement> ::=
    <schema definition>
  | <table definition>
  | <view definition>
  | <SQL-invoked routine>
  | <grant statement>
  | <role definition>
  | <domain definition>
  | <character set definition>
  | <collation definition>
  | <transliteration definition>
  | <assertion definition>
  | <trigger definition>
  | <user-defined type definition>
  | <user-defined cast definition>
  | <user-defined ordering definition>
  | <transform definition>
  | <sequence generator definition>

<SQL schema manipulation statement> ::=
    <drop schema statement>
  | <alter table statement>
  | <drop table statement>
  | <drop view statement>
  | <alter routine statement>
  | <drop routine statement>
  | <drop user-defined cast statement>
  | <revoke statement>
  | <drop role statement>
  | <alter domain statement>
  | <drop domain statement>
  | <drop character set statement>
  | <drop collation statement>
  | <drop transliteration statement>
  | <drop assertion statement>
  | <drop trigger statement>
  | <alter type statement>
  | <drop data type statement>
  | <drop user-defined ordering statement>
  | <alter transform statement>
  | <drop transform statement>
  | <alter sequence generator statement>
  | <drop sequence generator statement>

<SQL schema statement> ::=
    <SQL schema definition statement>
  | <SQL schema manipulation statement>

<SQL session statement> ::=
    <set session user identifier statement>
  | <set role statement>
  | <set local time zone statement>
  | <set session characteristics statement>
  | <set catalog statement>
  | <set schema statement>
  | <set names statement>
  | <set path statement>
  | <set transform group statement>
  | <set session collation statement>

<SQL special character> ::=
    <space>
  | <double quote>
  | <percent>
  | <ampersand>
  | <quote>
  | <left paren>
  | <right paren>
  | <asterisk>
  | <plus sign>
  | <comma>
  | <minus sign>
  | <period>
  | <solidus>
  | <colon>
  | <semicolon>
  | <less than operator>
  | <equals operator>
  | <greater than operator>
  | <question mark>
  | <left bracket>
  | <right bracket>
  | <circumflex>
  | <underscore>
  | <vertical bar>
  | <left brace>
  | <right brace>
  | <dollar sign>
  | <apostrophe>

<SQL statement name> ::=
    <statement name>
  | <extended statement name>

<SQL statement variable> ::=
    <simple value specification>

<SQL terminal character> ::=
    <SQL language character>

<SQL terminator> ::=
    END-EXEC
  | <semicolon>
  | <right paren>

<SQL transaction statement> ::=
    <start transaction statement>
  | <set transaction statement>
  | <set constraints mode statement>
  | <savepoint statement>
  | <release savepoint statement>
  | <commit statement>
  | <rollback statement>

<SQL-client module definition> ::=
    <module name clause> <language clause> <module authorization clause> 
    [ <module path specification> ] [ <module transform group specification> ] 
    [ <module collations> ] [ <temporary table declaration>... ] 
    <module contents>...

<SQL-client module name> ::=
    <identifier>

<SQL-data access indication> ::=
    NO SQL
  | CONTAINS SQL
  | READS SQL DATA
  | MODIFIES SQL DATA

<SQL-invoked function> ::=
    { <function specification> <method specification designator> } <routine body>

<SQL-invoked procedure> ::=
    PROCEDURE <schema qualified routine name> <SQL parameter declaration list> 
    <routine characteristics> <routine body>

<SQL-invoked routine> ::=
    <schema routine>

<SQL-path characteristic> ::=
    PATH <value specification>

<SQL-server name> ::=
    <simple value specification>

<SQLSTATE char> ::=
    <simple Latin upper case letter>
  | <digit>

<SQLSTATE class code> ::=
    <SQLSTATE char> <SQLSTATE char> !! See the Syntax Rules.

<SQLSTATE subclass code> ::=
    <SQLSTATE char> <SQLSTATE char> <SQLSTATE char> !! See the Syntax Rules.

<Unicode 4 digit escape value> ::=
    <Unicode escape character> <hexit> <hexit> <hexit> <hexit>

<Unicode 6 digit escape value> ::=
    <Unicode escape character> <plus sign> <hexit> <hexit> <hexit> <hexit> <hexit> 
    <hexit>

<Unicode character escape value> ::=
    <Unicode escape character> <Unicode escape character>

<Unicode character string literal> ::=
    [ <introducer> <character set specification> ] U <ampersand> <quote> 
    [ <Unicode representation>... ] <quote> 
    [ { <separator> <quote> [ <Unicode representation>... ] <quote> }... ] 
    <Unicode escape specifier>

<Unicode delimited identifier> ::=
    U <ampersand> <double quote> <Unicode delimiter body> <double quote> 
    <Unicode escape specifier>

<Unicode delimiter body> ::=
    <Unicode identifier part>...

<Unicode escape character> ::=
    !! See the Syntax Rules.

<Unicode escape specifier> ::=
    [ UESCAPE <quote> <Unicode escape character> <quote> ]

<Unicode escape value> ::=
    <Unicode 4 digit escape value>
  | <Unicode 6 digit escape value>
  | <Unicode character escape value>

<Unicode identifier part> ::=
    <delimited identifier part>
  | <Unicode escape value>

<Unicode representation> ::=
    <character representation>
  | <Unicode escape value>

<XQuery option flag> ::=
    <character value expression>

<XQuery pattern> ::=
    <character value expression>

<XQuery replacement string> ::=
    <character value expression>

<absolute value expression> ::=
    ABS <left paren> <numeric value expression> <right paren>

<action> ::=
    SELECT
  | SELECT <left paren> <privilege column list> <right paren>
  | SELECT <left paren> <privilege method list> <right paren>
  | DELETE
  | INSERT [ <left paren> <privilege column list> <right paren> ]
  | UPDATE [ <left paren> <privilege column list> <right paren> ]
  | REFERENCES [ <left paren> <privilege column list> <right paren> ]
  | USAGE
  | TRIGGER
  | UNDER
  | EXECUTE

<actual identifier> ::=
    <regular identifier>
  | <delimited identifier>
  | <Unicode delimited identifier>

<add attribute definition> ::=
    ADD ATTRIBUTE <attribute definition>

<add column definition> ::=
    ADD [ COLUMN ] <column definition>

<add column scope clause> ::=
    ADD <scope clause>

<add domain constraint definition> ::=
    ADD <domain constraint>

<add original method specification> ::=
    ADD <original method specification>

<add overriding method specification> ::=
    ADD <overriding method specification>

<add system time period column list> ::=
    ADD [ COLUMN ] <column definition 1> ADD [ COLUMN ] <column definition 2>

<add system versioning clause> ::=
    ADD <system versioning clause>

<add table constraint definition> ::=
    ADD <table constraint definition>

<add table period definition> ::=
    ADD <table period definition> [ <add system time period column list> ]

<add transform element list> ::=
    ADD <left paren> <transform element list> <right paren>

<aggregate function> ::=
    COUNT <left paren> <asterisk> <right paren> [ <filter clause> ]
  | <general set function> [ <filter clause> ]
  | <binary set function> [ <filter clause> ]
  | <ordered set function> [ <filter clause> ]
  | <array aggregate function> [ <filter clause> ]
  | <row pattern count function> [ <filter clause> ]
  | <JSON aggregate function> [ <filter clause> ]

<all> ::=
    ALL

<all fields column name list> ::=
    <column name list>

<all fields reference> ::=
    <value expression primary> <period> <asterisk> 
    [ AS <left paren> <all fields column name list> <right paren> ]

<all info target> ::=
    <simple target specification>

<all information> ::=
    <all info target> <equals operator> ALL [ <all qualifier> ]

<all qualifier> ::=
    STATEMENT
  | CONDITION [ <condition number> ]

<allocate descriptor statement> ::=
    ALLOCATE [ SQL ] DESCRIPTOR <conventional descriptor name> 
    [ WITH MAX <occurrences> ]

<allocate extended dynamic cursor statement> ::=
    ALLOCATE <extended cursor name> <cursor properties> FOR 
    <extended statement name>

<allocate received cursor statement> ::=
    ALLOCATE <cursor name> [ CURSOR ] FOR PROCEDURE <specific routine designator>

<alter column action> ::=
    <set column default clause>
  | <drop column default clause>
  | <set column not null clause>
  | <drop column not null clause>
  | <add column scope clause>
  | <drop column scope clause>
  | <alter column data type clause>
  | <alter identity column specification>
  | <drop identity property clause>
  | <drop column generation expression clause>

<alter column data type clause> ::=
    SET DATA TYPE <data type>

<alter column definition> ::=
    ALTER [ COLUMN ] <column name> <alter column action>

<alter domain action> ::=
    <set domain default clause>
  | <drop domain default clause>
  | <add domain constraint definition>
  | <drop domain constraint definition>

<alter domain statement> ::=
    ALTER DOMAIN <domain name> <alter domain action>

<alter group> ::=
    <group name> <left paren> <alter transform action list> <right paren>

<alter identity column option> ::=
    <alter sequence generator restart option>
  | SET <basic sequence generator option>

<alter identity column specification> ::=
    <set identity column generation clause> [ <alter identity column option>... ]
  | <alter identity column option>...

<alter routine behavior> ::=
    RESTRICT

<alter routine characteristic> ::=
    <language clause>
  | <parameter style clause>
  | <SQL-data access indication>
  | <null-call clause>
  | <returned result sets characteristic>
  | NAME <external routine name>

<alter routine characteristics> ::=
    <alter routine characteristic>...

<alter routine statement> ::=
    ALTER <specific routine designator> <alter routine characteristics> 
    <alter routine behavior>

<alter sequence generator option> ::=
    <alter sequence generator restart option>
  | <basic sequence generator option>

<alter sequence generator options> ::=
    <alter sequence generator option>...

<alter sequence generator restart option> ::=
    RESTART [ WITH <sequence generator restart value> ]

<alter sequence generator statement> ::=
    ALTER SEQUENCE <sequence generator name> <alter sequence generator options>

<alter table action> ::=
    <add column definition>
  | <alter column definition>
  | <drop column definition>
  | <add table constraint definition>
  | <alter table constraint definition>
  | <drop table constraint definition>
  | <add table period definition>
  | <drop table period definition>
  | <add system versioning clause>
  | <drop system versioning clause>

<alter table constraint definition> ::=
    ALTER CONSTRAINT <constraint name> <constraint enforcement>

<alter table statement> ::=
    ALTER TABLE <table name> <alter table action>

<alter transform action> ::=
    <add transform element list>
  | <drop transform element list>

<alter transform action list> ::=
    <alter transform action> [ { <comma> <alter transform action> }... ]

<alter transform statement> ::=
    ALTER { TRANSFORM TRANSFORMS } FOR <schema-resolved user-defined type name> 
    <alter group>...

<alter type action> ::=
    <add attribute definition>
  | <drop attribute definition>
  | <add original method specification>
  | <add overriding method specification>
  | <drop method specification>

<alter type statement> ::=
    ALTER TYPE <schema-resolved user-defined type name> <alter type action>

<ampersand> ::=
    &

<apostrophe> ::=
    '

<application time period name> ::=
    <identifier>

<application time period specification> ::=
    PERIOD FOR <application time period name>

<approximate numeric literal> ::=
    <mantissa> E <exponent>

<approximate numeric type> ::=
    FLOAT [ <left paren> <precision> <right paren> ]
  | REAL
  | DOUBLE PRECISION

<array aggregate function> ::=
    ARRAY_AGG <left paren> <value expression> 
    [ ORDER BY <sort specification list> ] <right paren>

<array concatenation> ::=
    <array value expression 1> <concatenation operator> <array primary>

<array element> ::=
    <value expression>

<array element list> ::=
    <array element> [ { <comma> <array element> }... ]

<array element reference> ::=
    <array value expression> <left bracket or trigraph> <numeric value expression> 
    <right bracket or trigraph>

<array primary> ::=
    <array value function>
  | <value expression primary>

<array type> ::=
    <data type> ARRAY 
    [ <left bracket or trigraph> <maximum cardinality> <right bracket or trigraph> ]

<array value constructor> ::=
    <array value constructor by enumeration>
  | <array value constructor by query>

<array value constructor by enumeration> ::=
    ARRAY <left bracket or trigraph> <array element list> 
    <right bracket or trigraph>

<array value constructor by query> ::=
    ARRAY <table subquery>

<array value expression> ::=
    <array concatenation>
  | <array primary>

<array value expression 1> ::=
    <array value expression>

<array value function> ::=
    <trim array function>

<as clause> ::=
    [ AS ] <column name>

<as subquery clause> ::=
    [ <left paren> <column name list> <right paren> ] AS <table subquery> 
    <with or without data>

<assertion definition> ::=
    CREATE ASSERTION <constraint name> CHECK <left paren> <search condition> 
    <right paren> [ <constraint characteristics> ]

<assigned row> ::=
    <contextually typed row value expression>

<asterisk> ::=
    *

<asterisked identifier> ::=
    <identifier>

<asterisked identifier chain> ::=
    <asterisked identifier> [ { <period> <asterisked identifier> }... ]

<attribute default> ::=
    <default clause>

<attribute definition> ::=
    <attribute name> <data type> [ <attribute default> ] [ <collate clause> ]

<attribute name> ::=
    <identifier>

<attribute or method reference> ::=
    <value expression primary> <dereference operator> <qualified identifier> 
    [ <SQL argument list> ]

<attributes specification> ::=
    ATTRIBUTES <attributes variable>

<attributes variable> ::=
    <simple value specification>

<authorization identifier> ::=
    <role name>
  | <user identifier>

<basic identifier chain> ::=
    <identifier chain>

<basic sequence generator option> ::=
    <sequence generator increment by option>
  | <sequence generator maxvalue option>
  | <sequence generator minvalue option>
  | <sequence generator cycle option>

<between predicate> ::=
    <row value predicand> <between predicate part 2>

<between predicate part 2> ::=
    [ NOT ] BETWEEN [ ASYMMETRIC SYMMETRIC ] <row value predicand> AND 
    <row value predicand>

<binary concatenation> ::=
    <binary value expression> <concatenation operator> <binary factor>

<binary factor> ::=
    <binary primary>

<binary large object string type> ::=
    BINARY LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  | BLOB [ <left paren> <large object length> <right paren> ]

<binary overlay function> ::=
    OVERLAY <left paren> <binary value expression> PLACING 
    <binary value expression> FROM <start position> [ FOR <string length> ] 
    <right paren>

<binary position expression> ::=
    POSITION <left paren> <binary value expression> IN <binary value expression> 
    <right paren>

<binary primary> ::=
    <value expression primary>
  | <string value function>

<binary set function> ::=
    <binary set function type> <left paren> <dependent variable expression> 
    <comma> <independent variable expression> <right paren>

<binary set function type> ::=
    COVAR_POP
  | COVAR_SAMP
  | CORR
  | REGR_SLOPE
  | REGR_INTERCEPT
  | REGR_COUNT
  | REGR_R2
  | REGR_AVGX
  | REGR_AVGY
  | REGR_SXX
  | REGR_SYY
  | REGR_SXY

<binary string literal> ::=
    X <quote> [ <space>... ] 
    [ { <hexit> [ <space>... ] <hexit> [ <space>... ] }... ] <quote> 
    [ { <separator> <quote> [ <space>... ] [ { <hexit> [ <space>... ] <hexit> [ <space>... ] }... ] <quote> }... ]

<binary string type> ::=
    BINARY [ <left paren> <length> <right paren> ]
  | BINARY VARYING <left paren> <length> <right paren>
  | VARBINARY <left paren> <length> <right paren>
  | <binary large object string type>

<binary substring function> ::=
    SUBSTRING <left paren> <binary value expression> FROM <start position> 
    [ FOR <string length> ] <right paren>

<binary trim function> ::=
    TRIM <left paren> <binary trim operands> <right paren>

<binary trim operands> ::=
    [ [ <trim specification> ] [ <trim octet> ] FROM ] <binary trim source>

<binary trim source> ::=
    <binary value expression>

<binary value expression> ::=
    <binary concatenation>
  | <binary factor>

<binary value function> ::=
    <binary substring function>
  | <binary trim function>
  | <binary overlay function>

<boolean factor> ::=
    [ NOT ] <boolean test>

<boolean literal> ::=
    TRUE
  | FALSE
  | UNKNOWN

<boolean predicand> ::=
    <parenthesized boolean value expression>
  | <nonparenthesized value expression primary>

<boolean primary> ::=
    <predicate>
  | <boolean predicand>

<boolean term> ::=
    <boolean factor>
  | <boolean term> AND <boolean factor>

<boolean test> ::=
    <boolean primary> [ IS [ NOT ] <truth value> ]

<boolean type> ::=
    BOOLEAN

<boolean value expression> ::=
    <boolean term>
  | <boolean value expression> OR <boolean term>

<bracketed comment> ::=
    <bracketed comment introducer> <bracketed comment contents> 
    <bracketed comment terminator>

<bracketed comment contents> ::=
    [ { <comment character> <separator> }... ] !! See the Syntax Rules.

<bracketed comment introducer> ::=
    /*

<bracketed comment terminator> ::=
    */

<call statement> ::=
    CALL <routine invocation>

<cardinality expression> ::=
    CARDINALITY <left paren> <collection value expression> <right paren>

<case abbreviation> ::=
    NULLIF <left paren> <value expression> <comma> <value expression> 
    <right paren>
  | COALESCE <left paren> <value expression> { <comma> <value expression> }... 
    <right paren>

<case expression> ::=
    <case abbreviation>
  | <case specification>

<case operand> ::=
    <row value predicand>
  | <overlaps predicate part 1>

<case specification> ::=
    <simple case>
  | <searched case>

<cast function> ::=
    <specific routine designator>

<cast operand> ::=
    <value expression>
  | <implicitly typed value specification>

<cast specification> ::=
    CAST <left paren> <cast operand> AS <cast target> [ FORMAT <cast template> ] 
    <right paren>

<cast target> ::=
    <domain name>
  | <data type>

<cast template> ::=
    <character string literal>

<cast to distinct> ::=
    CAST <left paren> SOURCE AS DISTINCT <right paren> WITH 
    <cast to distinct identifier>

<cast to distinct identifier> ::=
    <identifier>

<cast to ref> ::=
    CAST <left paren> SOURCE AS REF <right paren> WITH <cast to ref identifier>

<cast to ref identifier> ::=
    <identifier>

<cast to source> ::=
    CAST <left paren> DISTINCT AS SOURCE <right paren> WITH 
    <cast to source identifier>

<cast to source identifier> ::=
    <identifier>

<cast to type> ::=
    CAST <left paren> REF AS SOURCE <right paren> WITH <cast to type identifier>

<cast to type identifier> ::=
    <identifier>

<catalog name> ::=
    <identifier>

<catalog name characteristic> ::=
    CATALOG <value specification>

<ceiling function> ::=
    { CEIL CEILING } <left paren> <numeric value expression> <right paren>

<char length expression> ::=
    { CHAR_LENGTH CHARACTER_LENGTH } <left paren> <character value expression> 
    [ USING <char length units> ] <right paren>

<char length units> ::=
    CHARACTERS
  | OCTETS

<character enumeration> ::=
    <character specifier>
  | <character specifier> <minus sign> <character specifier>
  | <left bracket> <colon> <regular character set identifier> <colon> 
    <right bracket>

<character enumeration exclude> ::=
    <character enumeration>

<character enumeration include> ::=
    <character enumeration>

<character factor> ::=
    <character primary> [ <collate clause> ]

<character large object length> ::=
    <large object length> [ <char length units> ]

<character large object type> ::=
    CHARACTER LARGE OBJECT 
    [ <left paren> <character large object length> <right paren> ]
  | CHAR LARGE OBJECT 
    [ <left paren> <character large object length> <right paren> ]
  | CLOB [ <left paren> <character large object length> <right paren> ]

<character length> ::=
    <length> [ <char length units> ]

<character like predicate> ::=
    <row value predicand> <character like predicate part 2>

<character like predicate part 2> ::=
    [ NOT ] LIKE <character pattern> [ ESCAPE <escape character> ]

<character overlay function> ::=
    OVERLAY <left paren> <character value expression> PLACING 
    <character value expression> FROM <start position> [ FOR <string length> ] 
    [ USING <char length units> ] <right paren>

<character pattern> ::=
    <character value expression>

<character position expression> ::=
    POSITION <left paren> <character value expression 1> IN 
    <character value expression 2> [ USING <char length units> ] <right paren>

<character primary> ::=
    <value expression primary>
  | <string value function>

<character representation> ::=
    <nonquote character>
  | <quote symbol>

<character set definition> ::=
    CREATE CHARACTER SET <character set name> [ AS ] <character set source> 
    [ <collate clause> ]

<character set name> ::=
    [ <schema name> <period> ] <SQL language identifier>

<character set name characteristic> ::=
    NAMES <value specification>

<character set source> ::=
    GET <character set specification>

<character set specification> ::=
    <standard character set name>
  | <implementation-defined character set name>
  | <user-defined character set name>

<character set specification list> ::=
    <character set specification> [ { <comma> <character set specification> }... ]

<character specifier> ::=
    <non-escaped character>
  | <escaped character>

<character string literal> ::=
    [ <introducer> <character set specification> ] <quote> 
    [ <character representation>... ] <quote> 
    [ { <separator> <quote> [ <character representation>... ] <quote> }... ]

<character string type> ::=
    CHARACTER [ <left paren> <character length> <right paren> ]
  | CHAR [ <left paren> <character length> <right paren> ]
  | CHARACTER VARYING <left paren> <character length> <right paren>
  | CHAR VARYING <left paren> <character length> <right paren>
  | VARCHAR <left paren> <character length> <right paren>
  | <character large object type>

<character substring function> ::=
    SUBSTRING <left paren> <character value expression> FROM <start position> 
    [ FOR <string length> ] [ USING <char length units> ] <right paren>

<character transliteration> ::=
    TRANSLATE <left paren> <character value expression> USING 
    <transliteration name> <right paren>

<character value expression> ::=
    <concatenation>
  | <character factor>

<character value expression 1> ::=
    <character value expression>

<character value expression 2> ::=
    <character value expression>

<character value function> ::=
    <character substring function>
  | <regular expression substring function>
  | <regex substring function>
  | <fold>
  | <transcoding>
  | <character transliteration>
  | <regex transliteration>
  | <trim function>
  | <character overlay function>
  | <normalize function>
  | <specific type method>
  | <classifier function>

<check constraint definition> ::=
    CHECK <left paren> <search condition> <right paren>

<circumflex> ::=
    ^

<classifier function> ::=
    CLASSIFIER <left paren> [ <row pattern variable name> ] <right paren>

<close statement> ::=
    CLOSE <cursor name>

<collate clause> ::=
    COLLATE <collation name>

<collation definition> ::=
    CREATE COLLATION <collation name> FOR <character set specification> FROM 
    <existing collation name> [ <pad characteristic> ]

<collation name> ::=
    <schema qualified name>

<collation specification> ::=
    <value specification>

<collection derived table> ::=
    UNNEST <left paren> <collection value expression> 
    [ { <comma> <collection value expression> }... ] <right paren> 
    [ WITH ORDINALITY ]

<collection type> ::=
    <array type>
  | <multiset type>

<collection value constructor> ::=
    <array value constructor>
  | <multiset value constructor>

<collection value expression> ::=
    <array value expression>
  | <multiset value expression>

<colon> ::=
    :

<column constraint> ::=
    NOT NULL
  | <unique specification>
  | <references specification>
  | <check constraint definition>

<column constraint definition> ::=
    [ <constraint name definition> ] <column constraint> 
    [ <constraint characteristics> ]

<column default option> ::=
    INCLUDING DEFAULTS
  | EXCLUDING DEFAULTS

<column definition> ::=
    <column name> [ <data type or domain name> ] 
    [ <default clause> <identity column specification> <generation clause> <system time period start column specification> <system time period end column specification> ] 
    [ <column constraint definition>... ] [ <collate clause> ]

<column definition 1> ::=
    <column definition>

<column definition 2> ::=
    <column definition>

<column name> ::=
    <identifier>

<column name list> ::=
    <column name> [ { <comma> <column name> }... ]

<column option list> ::=
    [ <scope clause> ] [ <default clause> ] [ <column constraint definition>... ]

<column options> ::=
    <column name> WITH OPTIONS <column option list>

<column reference> ::=
    <basic identifier chain>
  | MODULE <period> <qualified identifier> <period> <column name>

<comma> ::=
    ,

<comment> ::=
    <simple comment>
  | <bracketed comment>

<comment character> ::=
    <nonquote character>
  | <quote>

<commit statement> ::=
    COMMIT [ WORK ] [ AND [ NO ] CHAIN ]

<common logarithm> ::=
    LOG10 <left paren> <numeric value expression> <right paren>

<common sequence generator option> ::=
    <sequence generator start with option>
  | <basic sequence generator option>

<common sequence generator options> ::=
    <common sequence generator option>...

<common value expression> ::=
    <numeric value expression>
  | <string value expression>
  | <datetime value expression>
  | <interval value expression>
  | <user-defined type value expression>
  | <reference value expression>
  | <collection value expression>

<comp op> ::=
    <equals operator>
  | <not equals operator>
  | <less than operator>
  | <greater than operator>
  | <less than or equals operator>
  | <greater than or equals operator>

<comparison predicate> ::=
    <row value predicand> <comparison predicate part 2>

<comparison predicate part 2> ::=
    <comp op> <row value predicand>

<computational operation> ::=
    AVG
  | MAX
  | MIN
  | SUM
  | EVERY
  | ANY
  | SOME
  | COUNT
  | STDDEV_POP
  | STDDEV_SAMP
  | VAR_SAMP
  | VAR_POP
  | COLLECT
  | FUSION
  | INTERSECTION

<concatenation> ::=
    <character value expression> <concatenation operator> <character factor>

<concatenation operator> ::=
    ||

<condition> ::=
    <SQL condition>

<condition action> ::=
    CONTINUE
  | <go to>

<condition information> ::=
    CONDITION <condition number> <condition information item> 
    [ { <comma> <condition information item> }... ]

<condition information item> ::=
    <simple target specification> <equals operator> 
    <condition information item name>

<condition information item name> ::=
    CATALOG_NAME
  | CLASS_ORIGIN
  | COLUMN_NAME
  | CONDITION_NUMBER
  | CONNECTION_NAME
  | CONSTRAINT_CATALOG
  | CONSTRAINT_NAME
  | CONSTRAINT_SCHEMA
  | CURSOR_NAME
  | MESSAGE_LENGTH
  | MESSAGE_OCTET_LENGTH
  | MESSAGE_TEXT
  | PARAMETER_MODE
  | PARAMETER_NAME
  | PARAMETER_ORDINAL_POSITION
  | RETURNED_SQLSTATE
  | ROUTINE_CATALOG
  | ROUTINE_NAME
  | ROUTINE_SCHEMA
  | SCHEMA_NAME
  | SERVER_NAME
  | SPECIFIC_NAME
  | SUBCLASS_ORIGIN
  | TABLE_NAME
  | TRIGGER_CATALOG
  | TRIGGER_NAME
  | TRIGGER_SCHEMA

<condition number> ::=
    <simple value specification>

<connect statement> ::=
    CONNECT TO <connection target>

<connection name> ::=
    <simple value specification>

<connection object> ::=
    DEFAULT
  | <connection name>

<connection target> ::=
    <SQL-server name> [ AS <connection name> ] [ USER <connection user name> ]
  | DEFAULT

<connection user name> ::=
    <simple value specification>

<constraint characteristics> ::=
    <constraint check time> [ [ NOT ] DEFERRABLE ] [ <constraint enforcement> ]
  | [ NOT ] DEFERRABLE [ <constraint check time> ] [ <constraint enforcement> ]
  | <constraint enforcement>

<constraint check time> ::=
    INITIALLY DEFERRED
  | INITIALLY IMMEDIATE

<constraint enforcement> ::=
    [ NOT ] ENFORCED

<constraint name> ::=
    <schema qualified name>

<constraint name definition> ::=
    CONSTRAINT <constraint name>

<constraint name list> ::=
    ALL
  | <constraint name> [ { <comma> <constraint name> }... ]

<constructor method selection> ::=
    <routine invocation>

<contextually typed row value constructor> ::=
    <common value expression>
  | <boolean value expression>
  | <contextually typed value specification>
  | <left paren> <contextually typed value specification> <right paren>
  | <left paren> <contextually typed row value constructor element> <comma> 
    <contextually typed row value constructor element list> <right paren>
  | ROW <left paren> <contextually typed row value constructor element list> 
    <right paren>

<contextually typed row value constructor element> ::=
    <value expression>
  | <contextually typed value specification>

<contextually typed row value constructor element list> ::=
    <contextually typed row value constructor element> 
    [ { <comma> <contextually typed row value constructor element> }... ]

<contextually typed row value expression> ::=
    <row value special case>
  | <contextually typed row value constructor>

<contextually typed row value expression list> ::=
    <contextually typed row value expression> 
    [ { <comma> <contextually typed row value expression> }... ]

<contextually typed table value constructor> ::=
    VALUES <contextually typed row value expression list>

<contextually typed value specification> ::=
    <implicitly typed value specification>
  | <default specification>

<conventional descriptor name> ::=
    <non-extended descriptor name>
  | <extended descriptor name>

<conventional dynamic cursor name> ::=
    <cursor name>
  | <extended cursor name>

<copartition clause> ::=
    COPARTITION <copartition list>

<copartition list> ::=
    <copartition specification> [ { <comma> <copartition specification> }... ]

<copartition specification> ::=
    <left paren> <range variable> <comma> <range variable> 
    [ { <comma> <range variable> }... ] <right paren>

<copy descriptor options> ::=
    NAME
  | TYPE
  | NAME <comma> TYPE
  | DATA

<copy descriptor statement> ::=
    <copy whole descriptor statement>
  | <copy item descriptor statement>

<copy item descriptor statement> ::=
    COPY <source descriptor name> VALUE <item number 1> <left paren> 
    <copy descriptor options> <right paren> TO <target descriptor name> VALUE 
    <item number 2>

<copy whole descriptor statement> ::=
    COPY <source descriptor name> TO <target descriptor name>

<correlation name> ::=
    <identifier>

<correlation or recognition> ::=
    [ AS ] <correlation name> [ <parenthesized derived column list> ]
  | <row pattern recognition clause and name>

<corresponding column list> ::=
    <column name list>

<corresponding spec> ::=
    CORRESPONDING [ BY <left paren> <corresponding column list> <right paren> ]

<cross join> ::=
    <table reference> CROSS JOIN <table factor>

<cube list> ::=
    CUBE <left paren> <ordinary grouping set list> <right paren>

<current collation specification> ::=
    COLLATION FOR <left paren> <string value expression> <right paren>

<current date value function> ::=
    CURRENT_DATE

<current local time value function> ::=
    LOCALTIME [ <left paren> <time precision> <right paren> ]

<current local timestamp value function> ::=
    LOCALTIMESTAMP [ <left paren> <timestamp precision> <right paren> ]

<current time value function> ::=
    CURRENT_TIME [ <left paren> <time precision> <right paren> ]

<current timestamp value function> ::=
    CURRENT_TIMESTAMP [ <left paren> <timestamp precision> <right paren> ]

<cursor holdability> ::=
    WITH HOLD
  | WITHOUT HOLD

<cursor name> ::=
    <local qualified name>

<cursor properties> ::=
    [ <cursor sensitivity> ] [ <cursor scrollability> ] CURSOR 
    [ <cursor holdability> ] [ <cursor returnability> ]

<cursor returnability> ::=
    WITH RETURN
  | WITHOUT RETURN

<cursor scrollability> ::=
    SCROLL
  | NO SCROLL

<cursor sensitivity> ::=
    SENSITIVE
  | INSENSITIVE
  | ASENSITIVE

<cursor specification> ::=
    <query expression> [ <updatability clause> ]

<cycle clause> ::=
    CYCLE <cycle column list> SET <cycle mark column> TO <cycle mark value> 
    DEFAULT <non-cycle mark value> USING <path column>

<cycle column> ::=
    <column name>

<cycle column list> ::=
    <cycle column> [ { <comma> <cycle column> }... ]

<cycle mark column> ::=
    <column name>

<cycle mark value> ::=
    <value expression>

<data change delta table> ::=
    <result option> TABLE <left paren> <data change statement> <right paren>

<data change statement> ::=
    <delete statement: searched>
  | <insert statement>
  | <merge statement>
  | <update statement: searched>

<data type> ::=
    <predefined type>
  | <row type>
  | <path-resolved user-defined type name>
  | <reference type>
  | <collection type>

<data type list> ::=
    <left paren> [ <data type> [ { <comma> <data type> }... ] ] <right paren>

<data type or domain name> ::=
    <data type>
  | <domain name>

<date literal> ::=
    DATE <date string>

<date string> ::=
    <quote> <unquoted date string> <quote>

<date value> ::=
    <years value> <minus sign> <months value> <minus sign> <days value>

<datetime factor> ::=
    <datetime primary> [ <time zone> ]

<datetime literal> ::=
    <date literal>
  | <time literal>
  | <timestamp literal>

<datetime primary> ::=
    <value expression primary>
  | <datetime value function>

<datetime term> ::=
    <datetime factor>

<datetime type> ::=
    DATE
  | TIME [ <left paren> <time precision> <right paren> ] 
    [ <with or without time zone> ]
  | TIMESTAMP [ <left paren> <timestamp precision> <right paren> ] 
    [ <with or without time zone> ]

<datetime value> ::=
    <unsigned integer>

<datetime value expression> ::=
    <datetime term>
  | <interval value expression> <plus sign> <datetime term>
  | <datetime value expression> <plus sign> <interval term>
  | <datetime value expression> <minus sign> <interval term>

<datetime value function> ::=
    <current date value function>
  | <current time value function>
  | <current timestamp value function>
  | <current local time value function>
  | <current local timestamp value function>

<day-time interval> ::=
    <days value> 
    [ <space> <hours value> [ <colon> <minutes value> [ <colon> <seconds value> ] ] ]

<day-time literal> ::=
    <day-time interval>
  | <time interval>

<days value> ::=
    <datetime value>

<deallocate descriptor statement> ::=
    DEALLOCATE [ SQL ] DESCRIPTOR <conventional descriptor name>

<deallocate prepared statement> ::=
    DEALLOCATE PREPARE <SQL statement name>

<decimal floating-point type> ::=
    DECFLOAT [ <left paren> <precision> <right paren> ]

<declare cursor> ::=
    DECLARE <cursor name> <cursor properties> FOR <cursor specification>

<default clause> ::=
    DEFAULT <default option>

<default expression> ::=
    <value expression>

<default option> ::=
    <literal>
  | <datetime value function>
  | USER
  | CURRENT_USER
  | CURRENT_ROLE
  | SESSION_USER
  | SYSTEM_USER
  | CURRENT_CATALOG
  | CURRENT_SCHEMA
  | CURRENT_PATH
  | <implicitly typed value specification>

<default specification> ::=
    DEFAULT

<delete rule> ::=
    ON DELETE <referential action>

<delete statement: positioned> ::=
    DELETE FROM <target table> [ [ AS ] <correlation name> ] WHERE CURRENT OF 
    <cursor name>

<delete statement: searched> ::=
    DELETE FROM <target table> 
    [ FOR PORTION OF <application time period name> FROM <point in time 1> TO <point in time 2> ] 
    [ [ AS ] <correlation name> ] [ WHERE <search condition> ]

<delimited identifier> ::=
    <double quote> <delimited identifier body> <double quote>

<delimited identifier body> ::=
    <delimited identifier part>...

<delimited identifier part> ::=
    <nondoublequote character>
  | <doublequote symbol>

<delimiter token> ::=
    <character string literal>
  | <date string>
  | <time string>
  | <timestamp string>
  | <interval string>
  | <delimited identifier>
  | <SQL special character>
  | <not equals operator>
  | <greater than or equals operator>
  | <less than or equals operator>
  | <concatenation operator>
  | <right arrow>
  | <left bracket trigraph>
  | <right bracket trigraph>
  | <double colon>
  | <double period>
  | <named argument assignment token>
  | <left brace minus>
  | <right minus brace>

<dependent variable expression> ::=
    <numeric value expression>

<dereference operator> ::=
    <right arrow>

<derived column> ::=
    <value expression> [ <as clause> ]

<derived column list> ::=
    <column name list>

<derived representation> ::=
    REF FROM <list of attributes>

<derived table> ::=
    <table subquery>

<describe input statement> ::=
    DESCRIBE INPUT <SQL statement name> <using descriptor> [ <nesting option> ]

<describe output statement> ::=
    DESCRIBE [ OUTPUT ] <described object> <using descriptor> [ <nesting option> ]

<describe statement> ::=
    <describe input statement>
  | <describe output statement>

<described object> ::=
    <SQL statement name>
  | CURSOR <cursor name> STRUCTURE

<descriptor argument> ::=
    <descriptor value constructor>
  | CAST <left paren> NULL AS DESCRIPTOR <right paren>

<descriptor column list> ::=
    <descriptor column specification> 
    [ { <comma> <descriptor column specification> }... ]

<descriptor column specification> ::=
    <column name> [ <data type> ]

<descriptor item name> ::=
    CARDINALITY
  | CHARACTER_SET_CATALOG
  | CHARACTER_SET_NAME
  | CHARACTER_SET_SCHEMA
  | COLLATION_CATALOG
  | COLLATION_NAME
  | COLLATION_SCHEMA
  | DATA
  | DATETIME_INTERVAL_CODE
  | DATETIME_INTERVAL_PRECISION
  | DEGREE
  | INDICATOR
  | KEY_MEMBER
  | LENGTH
  | LEVEL
  | NAME
  | NULLABLE
  | NULL_ORDERING
  | OCTET_LENGTH
  | PARAMETER_MODE
  | PARAMETER_ORDINAL_POSITION
  | PARAMETER_SPECIFIC_CATALOG
  | PARAMETER_SPECIFIC_NAME
  | PARAMETER_SPECIFIC_SCHEMA
  | PRECISION
  | RETURNED_CARDINALITY
  | RETURNED_LENGTH
  | RETURNED_OCTET_LENGTH
  | SCALE
  | SCOPE_CATALOG
  | SCOPE_NAME
  | SCOPE_SCHEMA
  | SORT_DIRECTION
  | TYPE
  | UNNAMED
  | USER_DEFINED_TYPE_CATALOG
  | USER_DEFINED_TYPE_NAME
  | USER_DEFINED_TYPE_SCHEMA
  | USER_DEFINED_TYPE_CODE

<descriptor name> ::=
    <conventional descriptor name>
  | <PTF descriptor name>

<descriptor parameter type> ::=
    DESCRIPTOR

<descriptor value constructor> ::=
    DESCRIPTOR <left paren> <descriptor column list> <right paren>

<deterministic characteristic> ::=
    DETERMINISTIC
  | NOT DETERMINISTIC

<diagnostics size> ::=
    DIAGNOSTICS SIZE <number of conditions>

<digit> ::=
    0
  | 1
  | 2
  | 3
  | 4
  | 5
  | 6
  | 7
  | 8
  | 9

<direct invocation> ::=
    <value expression primary> <period> <method name> [ <SQL argument list> ]

<disconnect object> ::=
    <connection object>
  | ALL
  | CURRENT

<disconnect statement> ::=
    DISCONNECT <disconnect object>

<dispatch clause> ::=
    STATIC DISPATCH

<distinct predicate> ::=
    <row value predicand 3> <distinct predicate part 2>

<distinct predicate part 2> ::=
    IS [ NOT ] DISTINCT FROM <row value predicand 4>

<dollar sign> ::=
    $

<domain constraint> ::=
    [ <constraint name definition> ] <check constraint definition> 
    [ <constraint characteristics> ]

<domain definition> ::=
    CREATE DOMAIN <domain name> [ AS ] <predefined type> [ <default clause> ] 
    [ <domain constraint>... ] [ <collate clause> ]

<domain name> ::=
    <schema qualified name>

<double colon> ::=
    ::

<double period> ::=
    ..

<double quote> ::=
    "

<doublequote symbol> ::=
    ""

<drop assertion statement> ::=
    DROP ASSERTION <constraint name> [ <drop behavior> ]

<drop attribute definition> ::=
    DROP ATTRIBUTE <attribute name> RESTRICT

<drop behavior> ::=
    CASCADE
  | RESTRICT

<drop character set statement> ::=
    DROP CHARACTER SET <character set name>

<drop collation statement> ::=
    DROP COLLATION <collation name> <drop behavior>

<drop column default clause> ::=
    DROP DEFAULT

<drop column definition> ::=
    DROP [ COLUMN ] <column name> <drop behavior>

<drop column generation expression clause> ::=
    DROP EXPRESSION

<drop column not null clause> ::=
    DROP NOT NULL

<drop column scope clause> ::=
    DROP SCOPE <drop behavior>

<drop data type statement> ::=
    DROP TYPE <schema-resolved user-defined type name> <drop behavior>

<drop domain constraint definition> ::=
    DROP CONSTRAINT <constraint name>

<drop domain default clause> ::=
    DROP DEFAULT

<drop domain statement> ::=
    DROP DOMAIN <domain name> <drop behavior>

<drop identity property clause> ::=
    DROP IDENTITY

<drop method specification> ::=
    DROP <specific method specification designator> RESTRICT

<drop role statement> ::=
    DROP ROLE <role name>

<drop routine statement> ::=
    DROP <specific routine designator> <drop behavior>

<drop schema statement> ::=
    DROP SCHEMA <schema name> <drop behavior>

<drop sequence generator statement> ::=
    DROP SEQUENCE <sequence generator name> <drop behavior>

<drop system versioning clause> ::=
    DROP SYSTEM VERSIONING <drop behavior>

<drop table constraint definition> ::=
    DROP CONSTRAINT <constraint name> <drop behavior>

<drop table period definition> ::=
    DROP <system or application time period specification> <drop behavior>

<drop table statement> ::=
    DROP TABLE <table name> <drop behavior>

<drop transform element list> ::=
    DROP <left paren> <transform kind> [ <comma> <transform kind> ] 
    <drop behavior> <right paren>

<drop transform statement> ::=
    DROP { TRANSFORM TRANSFORMS } <transforms to be dropped> FOR 
    <schema-resolved user-defined type name> <drop behavior>

<drop transliteration statement> ::=
    DROP TRANSLATION <transliteration name>

<drop trigger statement> ::=
    DROP TRIGGER <trigger name>

<drop user-defined cast statement> ::=
    DROP CAST <left paren> <source data type> AS <target data type> <right paren> 
    <drop behavior>

<drop user-defined ordering statement> ::=
    DROP ORDERING FOR <schema-resolved user-defined type name> <drop behavior>

<drop view statement> ::=
    DROP VIEW <table name> <drop behavior>

<dynamic close statement> ::=
    CLOSE <conventional dynamic cursor name>

<dynamic cursor name> ::=
    <conventional dynamic cursor name>
  | <PTF cursor name>

<dynamic declare cursor> ::=
    DECLARE <cursor name> <cursor properties> FOR <statement name>

<dynamic delete statement: positioned> ::=
    DELETE FROM <target table> WHERE CURRENT OF <conventional dynamic cursor name>

<dynamic fetch statement> ::=
    FETCH [ [ <fetch orientation> ] FROM ] <dynamic cursor name> 
    <output using clause>

<dynamic open statement> ::=
    OPEN <conventional dynamic cursor name> [ <input using clause> ]

<dynamic parameter specification> ::=
    <question mark>

<dynamic select statement> ::=
    <cursor specification>

<dynamic single row select statement> ::=
    <query specification>

<dynamic update statement: positioned> ::=
    UPDATE <target table> SET <set clause list> WHERE CURRENT OF 
    <conventional dynamic cursor name>

<else clause> ::=
    ELSE <result>

<embedded SQL Ada program> ::=
    !! See the Syntax Rules.

<embedded SQL C program> ::=
    !! See the Syntax Rules.

<embedded SQL COBOL program> ::=
    !! See the Syntax Rules.

<embedded SQL Fortran program> ::=
    !! See the Syntax Rules.

<embedded SQL MUMPS declare> ::=
    <SQL prefix> BEGIN DECLARE SECTION [ <embedded character set declaration> ] 
    [ <host variable definition>... ] END DECLARE SECTION <SQL terminator>

<embedded SQL MUMPS program> ::=
    !! See the Syntax Rules.

<embedded SQL PL/I program> ::=
    !! See the Syntax Rules.

<embedded SQL Pascal program> ::=
    !! See the Syntax Rules.

<embedded SQL begin declare> ::=
    <SQL prefix> BEGIN DECLARE SECTION [ <SQL terminator> ]

<embedded SQL declare section> ::=
    <embedded SQL begin declare> [ <embedded character set declaration> ] 
    [ <host variable definition>... ] <embedded SQL end declare>
  | <embedded SQL MUMPS declare>

<embedded SQL end declare> ::=
    <SQL prefix> END DECLARE SECTION [ <SQL terminator> ]

<embedded SQL host program> ::=
    <embedded SQL Ada program>
  | <embedded SQL C program>
  | <embedded SQL COBOL program>
  | <embedded SQL Fortran program>
  | <embedded SQL MUMPS program>
  | <embedded SQL Pascal program>
  | <embedded SQL PL/I program>

<embedded SQL statement> ::=
    <SQL prefix> <statement or declaration> [ <SQL terminator> ]

<embedded authorization clause> ::=
    SCHEMA <schema name>
  | AUTHORIZATION <embedded authorization identifier> 
    [ FOR STATIC { ONLY AND DYNAMIC } ]
  | SCHEMA <schema name> AUTHORIZATION <embedded authorization identifier> 
    [ FOR STATIC { ONLY AND DYNAMIC } ]

<embedded authorization declaration> ::=
    DECLARE <embedded authorization clause>

<embedded authorization identifier> ::=
    <module authorization identifier>

<embedded character set declaration> ::=
    SQL NAMES ARE <character set specification>

<embedded collation specification> ::=
    <module collations>

<embedded exception declaration> ::=
    WHENEVER <condition> <condition action>

<embedded path specification> ::=
    <path specification>

<embedded transform group specification> ::=
    <transform group specification>

<embedded variable name> ::=
    <colon> <host identifier>

<embedded variable specification> ::=
    <embedded variable name> [ <indicator variable> ]

<empty grouping set> ::=
    <left paren> <right paren>

<empty specification> ::=
    ARRAY <left bracket or trigraph> <right bracket or trigraph>
  | MULTISET <left bracket or trigraph> <right bracket or trigraph>

<end field> ::=
    <non-second primary datetime field>
  | SECOND [ <left paren> <interval fractional seconds precision> <right paren> ]

<equals operator> ::=
    =

<equals ordering form> ::=
    EQUALS ONLY BY <ordering category>

<escape character> ::=
    <character value expression>

<escape octet> ::=
    <binary value expression>

<escaped character> ::=
    !! See the Syntax Rules.

<exact numeric literal> ::=
    <unsigned integer> [ <period> [ <unsigned integer> ] ]
  | <period> <unsigned integer>

<exact numeric type> ::=
    NUMERIC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  | DECIMAL [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  | DEC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  | SMALLINT
  | INTEGER
  | INT
  | BIGINT

<exclusive user-defined type specification> ::=
    ONLY <path-resolved user-defined type name>

<execute immediate statement> ::=
    EXECUTE IMMEDIATE <SQL statement variable>

<execute statement> ::=
    EXECUTE <SQL statement name> [ <result using clause> ] 
    [ <parameter using clause> ]

<existing collation name> ::=
    <collation name>

<existing transliteration name> ::=
    <transliteration name>

<existing window name> ::=
    <window name>

<exists predicate> ::=
    EXISTS <table subquery>

<explicit row value constructor> ::=
    <left paren> <row value constructor element> <comma> 
    <row value constructor element list> <right paren>
  | ROW <left paren> <row value constructor element list> <right paren>
  | <row subquery>

<explicit table> ::=
    TABLE <table or query name>

<exponent> ::=
    <signed integer>

<exponential function> ::=
    EXP <left paren> <numeric value expression> <right paren>

<extended cursor name> ::=
    [ <scope option> ] <simple value specification>

<extended descriptor name> ::=
    [ <scope option> ] <simple value specification>

<extended statement name> ::=
    [ <scope option> ] <simple value specification>

<external body reference> ::=
    EXTERNAL [ NAME <external routine name> ] [ <parameter style clause> ] 
    [ <transform group specification> ] [ <external security clause> ]

<external routine name> ::=
    <identifier>
  | <character string literal>

<external security clause> ::=
    EXTERNAL SECURITY DEFINER
  | EXTERNAL SECURITY INVOKER
  | EXTERNAL SECURITY IMPLEMENTATION DEFINED

<externally-invoked procedure> ::=
    PROCEDURE <procedure name> <host parameter declaration list> <semicolon> 
    <SQL procedure statement> <semicolon>

<extract expression> ::=
    EXTRACT <left paren> <extract field> FROM <extract source> <right paren>

<extract field> ::=
    <primary datetime field>
  | <time zone field>

<extract source> ::=
    <datetime value expression>
  | <interval value expression>

<factor> ::=
    [ <sign> ] <numeric primary>

<fetch first clause> ::=
    FETCH { FIRST NEXT } [ <fetch first quantity> ] { ROW ROWS } 
    { ONLY WITH TIES }

<fetch first percentage> ::=
    <simple value specification> PERCENT

<fetch first quantity> ::=
    <fetch first row count>
  | <fetch first percentage>

<fetch first row count> ::=
    <simple value specification>

<fetch orientation> ::=
    NEXT
  | PRIOR
  | FIRST
  | LAST
  | { ABSOLUTE RELATIVE } <simple value specification>

<fetch statement> ::=
    FETCH [ [ <fetch orientation> ] FROM ] <cursor name> INTO <fetch target list>

<fetch target list> ::=
    <target specification> [ { <comma> <target specification> }... ]

<field definition> ::=
    <field name> <data type>

<field name> ::=
    <identifier>

<field reference> ::=
    <value expression primary> <period> <field name>

<filter clause> ::=
    FILTER <left paren> WHERE <search condition> <right paren>

<finality> ::=
    FINAL
  | NOT FINAL

<first or last> ::=
    FIRST
  | LAST

<first or last value> ::=
    FIRST_VALUE
  | LAST_VALUE

<first or last value function> ::=
    <first or last value> <left paren> <value expression> <right paren> 
    [ <null treatment> ]

<floor function> ::=
    FLOOR <left paren> <numeric value expression> <right paren>

<fold> ::=
    { UPPER LOWER } <left paren> <character value expression> <right paren>

<free locator statement> ::=
    FREE LOCATOR <locator reference> [ { <comma> <locator reference> }... ]

<from clause> ::=
    FROM <table reference list>

<from constructor> ::=
    [ <left paren> <insert column list> <right paren> ] [ <override clause> ] 
    <contextually typed table value constructor>

<from default> ::=
    DEFAULT VALUES

<from first or last> ::=
    FROM FIRST
  | FROM LAST

<from sql> ::=
    FROM SQL WITH <from sql function>

<from sql function> ::=
    <specific routine designator>

<from subquery> ::=
    [ <left paren> <insert column list> <right paren> ] [ <override clause> ] 
    <query expression>

<full ordering form> ::=
    ORDER FULL BY <ordering category>

<function specification> ::=
    FUNCTION <schema qualified routine name> <SQL parameter declaration list> 
    <returns clause> <routine characteristics> [ <dispatch clause> ]

<general literal> ::=
    <character string literal>
  | <national character string literal>
  | <Unicode character string literal>
  | <binary string literal>
  | <datetime literal>
  | <interval literal>
  | <boolean literal>

<general logarithm argument> ::=
    <numeric value expression>

<general logarithm base> ::=
    <numeric value expression>

<general logarithm function> ::=
    LOG <left paren> <general logarithm base> <comma> <general logarithm argument> 
    <right paren>

<general set function> ::=
    <set function type> <left paren> [ <set quantifier> ] <value expression> 
    <right paren>

<general value specification> ::=
    <host parameter specification>
  | <SQL parameter reference>
  | <dynamic parameter specification>
  | <embedded variable specification>
  | <current collation specification>
  | CURRENT_CATALOG
  | CURRENT_DEFAULT_TRANSFORM_GROUP
  | CURRENT_PATH
  | CURRENT_ROLE
  | CURRENT_SCHEMA
  | CURRENT_TRANSFORM_GROUP_FOR_TYPE <path-resolved user-defined type name>
  | CURRENT_USER
  | SESSION_USER
  | SYSTEM_USER
  | USER
  | VALUE

<generalized expression> ::=
    <value expression> AS <path-resolved user-defined type name>

<generalized invocation> ::=
    <left paren> <value expression primary> AS <data type> <right paren> <period> 
    <method name> [ <SQL argument list> ]

<generation clause> ::=
    <generation rule> AS <generation expression>

<generation expression> ::=
    <left paren> <value expression> <right paren>

<generation option> ::=
    INCLUDING GENERATED
  | EXCLUDING GENERATED

<generation rule> ::=
    GENERATED ALWAYS

<generic table parameter type> ::=
    TABLE [ <pass through option> ] [ <generic table semantics> ]

<generic table pruning> ::=
    PRUNE ON EMPTY
  | KEEP ON EMPTY

<generic table semantics> ::=
    WITH ROW SEMANTICS
  | WITH SET SEMANTICS [ <generic table pruning> ]

<get descriptor information> ::=
    <get header information> [ { <comma> <get header information> }... ]
  | VALUE <item number> <get item information> 
    [ { <comma> <get item information> }... ]

<get descriptor statement> ::=
    GET [ SQL ] DESCRIPTOR <descriptor name> <get descriptor information>

<get diagnostics statement> ::=
    GET DIAGNOSTICS <SQL diagnostics information>

<get header information> ::=
    <simple target specification 1> <equals operator> <header item name>

<get item information> ::=
    <simple target specification 2> <equals operator> <descriptor item name>

<global or local> ::=
    GLOBAL
  | LOCAL

<go to> ::=
    { GOTO GO TO } <goto target>

<goto target> ::=
    <host label identifier>
  | <unsigned integer>
  | <host PL/I label variable>

<grant privilege statement> ::=
    GRANT <privileges> TO <grantee> [ { <comma> <grantee> }... ] 
    [ WITH HIERARCHY OPTION ] [ WITH GRANT OPTION ] [ GRANTED BY <grantor> ]

<grant role statement> ::=
    GRANT <role granted> [ { <comma> <role granted> }... ] TO <grantee> 
    [ { <comma> <grantee> }... ] [ WITH ADMIN OPTION ] 
    [ GRANTED BY <grantor> ]

<grant statement> ::=
    <grant privilege statement>
  | <grant role statement>

<grantee> ::=
    PUBLIC
  | <authorization identifier>

<grantor> ::=
    CURRENT_USER
  | CURRENT_ROLE

<greater than operator> ::=
    >

<greater than or equals operator> ::=
    >=

<group by clause> ::=
    GROUP BY [ <set quantifier> ] <grouping element list>

<group name> ::=
    <identifier>

<group specification> ::=
    <group name> FOR TYPE <path-resolved user-defined type name>

<grouping column reference> ::=
    <column reference> [ <collate clause> ]

<grouping column reference list> ::=
    <grouping column reference> [ { <comma> <grouping column reference> }... ]

<grouping element> ::=
    <ordinary grouping set>
  | <rollup list>
  | <cube list>
  | <grouping sets specification>
  | <empty grouping set>

<grouping element list> ::=
    <grouping element> [ { <comma> <grouping element> }... ]

<grouping operation> ::=
    GROUPING <left paren> <column reference> [ { <comma> <column reference> }... ] 
    <right paren>

<grouping set> ::=
    <ordinary grouping set>
  | <rollup list>
  | <cube list>
  | <grouping sets specification>
  | <empty grouping set>

<grouping set list> ::=
    <grouping set> [ { <comma> <grouping set> }... ]

<grouping sets specification> ::=
    GROUPING SETS <left paren> <grouping set list> <right paren>

<having clause> ::=
    HAVING <search condition>

<header item name> ::=
    COUNT
  | KEY_TYPE
  | DYNAMIC_FUNCTION
  | DYNAMIC_FUNCTION_CODE
  | TOP_LEVEL_COUNT

<hexit> ::=
    <digit>
  | A
  | B
  | C
  | D
  | E
  | F
  | a
  | b
  | c
  | d
  | e
  | f

<high value> ::=
    <unsigned integer>

<hold locator statement> ::=
    HOLD LOCATOR <locator reference> [ { <comma> <locator reference> }... ]

<host PL/I label variable> ::=
    !! See the Syntax Rules.

<host identifier> ::=
    <Ada host identifier>
  | <C host identifier>
  | <COBOL host identifier>
  | <Fortran host identifier>
  | <MUMPS host identifier>
  | <Pascal host identifier>
  | <PL/I host identifier>

<host label identifier> ::=
    !! See the Syntax Rules.

<host parameter data type> ::=
    <data type> [ <locator indication> ]

<host parameter declaration> ::=
    <host parameter name> <host parameter data type>
  | <status parameter>

<host parameter declaration list> ::=
    <left paren> <host parameter declaration> 
    [ { <comma> <host parameter declaration> }... ] <right paren>

<host parameter name> ::=
    <colon> <identifier>

<host parameter specification> ::=
    <host parameter name> [ <indicator parameter> ]

<host variable definition> ::=
    <Ada variable definition>
  | <C variable definition>
  | <COBOL variable definition>
  | <Fortran variable definition>
  | <MUMPS variable definition>
  | <Pascal variable definition>
  | <PL/I variable definition>

<hours value> ::=
    <datetime value>

<hypothetical set function> ::=
    <rank function type> <left paren> 
    <hypothetical set function value expression list> <right paren> 
    <within group specification>

<hypothetical set function value expression list> ::=
    <value expression> [ { <comma> <value expression> }... ]

<identifier> ::=
    <actual identifier>

<identifier body> ::=
    <identifier start> [ <identifier part>... ]

<identifier chain> ::=
    <identifier> [ { <period> <identifier> }... ]

<identifier extend> ::=
    !! See the Syntax Rules.

<identifier part> ::=
    <identifier start>
  | <identifier extend>

<identifier start> ::=
    !! See the Syntax Rules.

<identity column restart option> ::=
    CONTINUE IDENTITY
  | RESTART IDENTITY

<identity column specification> ::=
    GENERATED { ALWAYS BY DEFAULT } AS IDENTITY 
    [ <left paren> <common sequence generator options> <right paren> ]

<identity option> ::=
    INCLUDING IDENTITY
  | EXCLUDING IDENTITY

<implementation-defined JSON representation option> ::=
    !! See the Syntax Rules.

<implementation-defined character set name> ::=
    <character set name>

<implicitly typed value specification> ::=
    <null specification>
  | <empty specification>

<in predicate> ::=
    <row value predicand> <in predicate part 2>

<in predicate part 2> ::=
    [ NOT ] IN <in predicate value>

<in predicate value> ::=
    <table subquery>
  | <left paren> <in value list> <right paren>

<in value list> ::=
    <row value expression> [ { <comma> <row value expression> }... ]

<in-line window specification> ::=
    <window specification>

<inclusive user-defined type specification> ::=
    <path-resolved user-defined type name>

<independent variable expression> ::=
    <numeric value expression>

<indicator parameter> ::=
    [ INDICATOR ] <host parameter name>

<indicator variable> ::=
    [ INDICATOR ] <embedded variable name>

<input using clause> ::=
    <using arguments>
  | <using input descriptor>

<insert column list> ::=
    <column name list>

<insert columns and source> ::=
    <from subquery>
  | <from constructor>
  | <from default>

<insert statement> ::=
    INSERT INTO <insertion target> <insert columns and source>

<insertion target> ::=
    <table name>

<instantiable clause> ::=
    INSTANTIABLE
  | NOT INSTANTIABLE

<interval absolute value function> ::=
    ABS <left paren> <interval value expression> <right paren>

<interval factor> ::=
    [ <sign> ] <interval primary>

<interval fractional seconds precision> ::=
    <unsigned integer>

<interval leading field precision> ::=
    <unsigned integer>

<interval literal> ::=
    INTERVAL [ <sign> ] <interval string> <interval qualifier>

<interval primary> ::=
    <value expression primary> [ <interval qualifier> ]
  | <interval value function>

<interval qualifier> ::=
    <start field> TO <end field>
  | <single datetime field>

<interval string> ::=
    <quote> <unquoted interval string> <quote>

<interval term> ::=
    <interval factor>
  | <interval term 2> <asterisk> <factor>
  | <interval term 2> <solidus> <factor>
  | <term> <asterisk> <interval factor>

<interval term 1> ::=
    <interval term>

<interval term 2> ::=
    <interval term>

<interval type> ::=
    INTERVAL <interval qualifier>

<interval value expression> ::=
    <interval term>
  | <interval value expression 1> <plus sign> <interval term 1>
  | <interval value expression 1> <minus sign> <interval term 1>
  | <left paren> <datetime value expression> <minus sign> <datetime term> 
    <right paren> <interval qualifier>

<interval value expression 1> ::=
    <interval value expression>

<interval value function> ::=
    <interval absolute value function>

<into argument> ::=
    <target specification>

<into arguments> ::=
    INTO <into argument> [ { <comma> <into argument> }... ]

<into descriptor> ::=
    INTO [ SQL ] DESCRIPTOR <descriptor name>

<introducer> ::=
    <underscore>

<inverse distribution function> ::=
    <inverse distribution function type> <left paren> 
    <inverse distribution function argument> <right paren> 
    <within group specification>

<inverse distribution function argument> ::=
    <numeric value expression>

<inverse distribution function type> ::=
    PERCENTILE_CONT
  | PERCENTILE_DISC

<isolation level> ::=
    ISOLATION LEVEL <level of isolation>

<item number> ::=
    <simple value specification>

<item number 1> ::=
    <simple value specification>

<item number 2> ::=
    <simple value specification>

<join column list> ::=
    <column name list>

<join condition> ::=
    ON <search condition>

<join correlation name> ::=
    <correlation name>

<join specification> ::=
    <join condition>
  | <named columns join>

<join type> ::=
    INNER
  | <outer join type> [ OUTER ]

<joined table> ::=
    <cross join>
  | <qualified join>
  | <natural join>

<key word> ::=
    <reserved word>
  | <non-reserved word>

<language clause> ::=
    LANGUAGE <language name>

<language name> ::=
    ADA
  | C
  | COBOL
  | FORTRAN
  | M
  | MUMPS
  | PASCAL
  | PLI
  | SQL

<large object length> ::=
    <unsigned integer> [ <multiplier> ]
  | <large object length token>

<large object length token> ::=
    <digit>... <multiplier>

<lateral derived table> ::=
    LATERAL <table subquery>

<lead or lag> ::=
    LEAD
  | LAG

<lead or lag extent> ::=
    <value expression>

<lead or lag function> ::=
    <lead or lag> <left paren> <lead or lag extent> 
    [ <comma> <offset> [ <comma> <default expression> ] ] <right paren> 
    [ <null treatment> ]

<left brace> ::=
    {  }

<left brace minus> ::=
    {-

<left bracket> ::=
    [  ]

<left bracket or trigraph> ::=
    <left bracket>
  | <left bracket trigraph>

<left bracket trigraph> ::=
    ??(

<left paren> ::=
    (

<length> ::=
    <unsigned integer>

<length expression> ::=
    <char length expression>
  | <octet length expression>

<less than operator> ::=
    <>

<less than or equals operator> ::=
    <>

<level of isolation> ::=
    READ UNCOMMITTED
  | READ COMMITTED
  | REPEATABLE READ
  | SERIALIZABLE

<levels clause> ::=
    CASCADED
  | LOCAL

<like clause> ::=
    LIKE <table name> [ <like options> ]

<like option> ::=
    <identity option>
  | <column default option>
  | <generation option>

<like options> ::=
    <like option>...

<like predicate> ::=
    <character like predicate>
  | <octet like predicate>

<list of attributes> ::=
    <left paren> <attribute name> [ { <comma> <attribute name> }... ] 
    <right paren>

<listagg count indication> ::=
    WITH COUNT
  | WITHOUT COUNT

<listagg overflow clause> ::=
    ON OVERFLOW <overflow behavior>

<listagg separator> ::=
    <character string literal>

<listagg set function> ::=
    LISTAGG <left paren> [ <set quantifier> ] <character value expression> <comma> 
    <listagg separator> [ <listagg overflow clause> ] <right paren> 
    <within group specification>

<listagg truncation filler> ::=
    <character string literal>

<literal> ::=
    <signed numeric literal>
  | <general literal>

<local or schema qualified name> ::=
    [ <local or schema qualifier> <period> ] <qualified identifier>

<local or schema qualifier> ::=
    <schema name>
  | <local qualifier>

<local qualified name> ::=
    [ <local qualifier> <period> ] <qualified identifier>

<local qualifier> ::=
    MODULE

<locator indication> ::=
    AS LOCATOR

<locator reference> ::=
    <host parameter name>
  | <embedded variable name>
  | <dynamic parameter specification>

<logical offset> ::=
    <simple value specification>
  | <dynamic parameter specification>

<low value> ::=
    <unsigned integer>

<major category> ::=
    SQLEXCEPTION
  | SQLWARNING
  | NOT FOUND

<mantissa> ::=
    <exact numeric literal>

<map category> ::=
    MAP WITH <map function specification>

<map function specification> ::=
    <specific routine designator>

<match number function> ::=
    MATCH_NUMBER <left paren> <right paren>

<match predicate> ::=
    <row value predicand> <match predicate part 2>

<match predicate part 2> ::=
    MATCH [ UNIQUE ] [ SIMPLE PARTIAL FULL ] <table subquery>

<match type> ::=
    FULL
  | PARTIAL
  | SIMPLE

<max cardinality expression> ::=
    ARRAY_MAX_CARDINALITY <left paren> <array value expression> <right paren>

<maximum cardinality> ::=
    <unsigned integer>

<maximum returned result sets> ::=
    <unsigned integer>

<measure name> ::=
    <identifier>

<member> ::=
    <attribute definition>

<member list> ::=
    <left paren> <member> [ { <comma> <member> }... ] <right paren>

<member name> ::=
    <member name alternatives> [ <data type list> ]

<member name alternatives> ::=
    <schema qualified routine name>
  | <method name>

<member predicate> ::=
    <row value predicand> <member predicate part 2>

<member predicate part 2> ::=
    [ NOT ] MEMBER [ OF ] <multiset value expression>

<merge correlation name> ::=
    <correlation name>

<merge delete specification> ::=
    DELETE

<merge insert specification> ::=
    INSERT [ <left paren> <insert column list> <right paren> ] 
    [ <override clause> ] VALUES <merge insert value list>

<merge insert value element> ::=
    <value expression>
  | <contextually typed value specification>

<merge insert value list> ::=
    <left paren> <merge insert value element> 
    [ { <comma> <merge insert value element> }... ] <right paren>

<merge operation specification> ::=
    <merge when clause>...

<merge statement> ::=
    MERGE INTO <target table> [ [ AS ] <merge correlation name> ] USING 
    <table reference> ON <search condition> <merge operation specification>

<merge update or delete specification> ::=
    <merge update specification>
  | <merge delete specification>

<merge update specification> ::=
    UPDATE SET <set clause list>

<merge when clause> ::=
    <merge when matched clause>
  | <merge when not matched clause>

<merge when matched clause> ::=
    WHEN MATCHED [ AND <search condition> ] THEN 
    <merge update or delete specification>

<merge when not matched clause> ::=
    WHEN NOT MATCHED [ AND <search condition> ] THEN <merge insert specification>

<method characteristic> ::=
    <language clause>
  | <parameter style clause>
  | <deterministic characteristic>
  | <SQL-data access indication>
  | <null-call clause>

<method characteristics> ::=
    <method characteristic>...

<method invocation> ::=
    <direct invocation>
  | <generalized invocation>

<method name> ::=
    <identifier>

<method selection> ::=
    <routine invocation>

<method specification> ::=
    <original method specification>
  | <overriding method specification>

<method specification designator> ::=
    SPECIFIC METHOD <specific method name>
  | [ INSTANCE STATIC CONSTRUCTOR ] METHOD <method name> 
    <SQL parameter declaration list> [ <returns clause> ] FOR 
    <schema-resolved user-defined type name>

<method specification list> ::=
    <method specification> [ { <comma> <method specification> }... ]

<minus sign> ::=
    -

<minutes value> ::=
    <datetime value>

<module authorization clause> ::=
    SCHEMA <schema name>
  | AUTHORIZATION <module authorization identifier> 
    [ FOR STATIC { ONLY AND DYNAMIC } ]
  | SCHEMA <schema name> AUTHORIZATION <module authorization identifier> 
    [ FOR STATIC { ONLY AND DYNAMIC } ]

<module authorization identifier> ::=
    <authorization identifier>

<module character set specification> ::=
    NAMES ARE <character set specification>

<module collation specification> ::=
    COLLATION <collation name> [ FOR <character set specification list> ]

<module collations> ::=
    <module collation specification>...

<module contents> ::=
    <declare cursor>
  | <dynamic declare cursor>
  | <externally-invoked procedure>

<module name clause> ::=
    MODULE [ <SQL-client module name> ] [ <module character set specification> ]

<module path specification> ::=
    <path specification>

<module transform group specification> ::=
    <transform group specification>

<modulus expression> ::=
    MOD <left paren> <numeric value expression dividend> <comma> 
    <numeric value expression divisor> <right paren>

<months value> ::=
    <datetime value>

<multiple column assignment> ::=
    <set target list> <equals operator> <assigned row>

<multiple group specification> ::=
    <group specification> [ { <comma> <group specification> }... ]

<multiplier> ::=
    K
  | M
  | G
  | T
  | P

<multiset element> ::=
    <value expression>

<multiset element list> ::=
    <multiset element> [ { <comma> <multiset element> }... ]

<multiset element reference> ::=
    ELEMENT <left paren> <multiset value expression> <right paren>

<multiset primary> ::=
    <multiset value function>
  | <value expression primary>

<multiset set function> ::=
    SET <left paren> <multiset value expression> <right paren>

<multiset term> ::=
    <multiset primary>
  | <multiset term> MULTISET INTERSECT [ ALL DISTINCT ] <multiset primary>

<multiset type> ::=
    <data type> MULTISET

<multiset value constructor> ::=
    <multiset value constructor by enumeration>
  | <multiset value constructor by query>
  | <table value constructor by query>

<multiset value constructor by enumeration> ::=
    MULTISET <left bracket or trigraph> <multiset element list> 
    <right bracket or trigraph>

<multiset value constructor by query> ::=
    MULTISET <table subquery>

<multiset value expression> ::=
    <multiset term>
  | <multiset value expression> MULTISET UNION [ ALL DISTINCT ] <multiset term>
  | <multiset value expression> MULTISET EXCEPT [ ALL DISTINCT ] <multiset term>

<multiset value function> ::=
    <multiset set function>

<mutated set clause> ::=
    <mutated target> <period> <method name>

<mutated target> ::=
    <object column>
  | <mutated set clause>

<named argument SQL argument> ::=
    <value expression>
  | <target specification>
  | <contextually typed value specification>
  | <table argument>
  | <descriptor argument>

<named argument assignment token> ::=
    =>

<named argument specification> ::=
    <SQL parameter name> <named argument assignment token> 
    <named argument SQL argument>

<named columns join> ::=
    USING <left paren> <join column list> <right paren> 
    [ AS <join correlation name> ]

<national character large object type> ::=
    NATIONAL CHARACTER LARGE OBJECT 
    [ <left paren> <character large object length> <right paren> ]
  | NCHAR LARGE OBJECT 
    [ <left paren> <character large object length> <right paren> ]
  | NCLOB [ <left paren> <character large object length> <right paren> ]

<national character string literal> ::=
    N <quote> [ <character representation>... ] <quote> 
    [ { <separator> <quote> [ <character representation>... ] <quote> }... ]

<national character string type> ::=
    NATIONAL CHARACTER [ <left paren> <character length> <right paren> ]
  | NATIONAL CHAR [ <left paren> <character length> <right paren> ]
  | NCHAR [ <left paren> <character length> <right paren> ]
  | NATIONAL CHARACTER VARYING <left paren> <character length> <right paren>
  | NATIONAL CHAR VARYING <left paren> <character length> <right paren>
  | NCHAR VARYING <left paren> <character length> <right paren>
  | <national character large object type>

<natural join> ::=
    { <table reference> <partitioned join table> } NATURAL [ <join type> ] JOIN 
    { <table factor> <partitioned join table> }

<natural logarithm> ::=
    LN <left paren> <numeric value expression> <right paren>

<nested row number function> ::=
    ROW_NUMBER <left paren> <row marker> <right paren>

<nested window function> ::=
    <nested row number function>
  | <value_of expression at row>

<nesting option> ::=
    WITH NESTING
  | WITHOUT NESTING

<new invocation> ::=
    <method invocation>
  | <routine invocation>

<new specification> ::=
    NEW <path-resolved user-defined type name> <SQL argument list>

<new transition table name> ::=
    <transition table name>

<new transition variable name> ::=
    <correlation name>

<new window name> ::=
    <window name>

<newline> ::=
    !! See the Syntax Rules.

<next value expression> ::=
    NEXT VALUE FOR <sequence generator name>

<non-cycle mark value> ::=
    <value expression>

<non-escaped character> ::=
    !! See the Syntax Rules.

<non-extended descriptor name> ::=
    <identifier>

<non-reserved word> ::=
    A
  | ABSOLUTE
  | ACTION
  | ADA
  | ADD
  | ADMIN
  | AFTER
  | ALWAYS
  | ASC
  | ASSERTION
  | ASSIGNMENT
  | ATTRIBUTE
  | ATTRIBUTES
  | BEFORE
  | BERNOULLI
  | BREADTH
  | C
  | CASCADE
  | CATALOG
  | CATALOG_NAME
  | CHAIN
  | CHAINING
  | CHARACTER_SET_CATALOG
  | CHARACTER_SET_NAME
  | CHARACTER_SET_SCHEMA
  | CHARACTERISTICS
  | CHARACTERS
  | CLASS_ORIGIN
  | COBOL
  | COLLATION
  | COLLATION_CATALOG
  | COLLATION_NAME
  | COLLATION_SCHEMA
  | COLUMNS
  | COLUMN_NAME
  | COMMAND_FUNCTION
  | COMMAND_FUNCTION_CODE
  | COMMITTED
  | CONDITIONAL
  | CONDITION_NUMBER
  | CONNECTION
  | CONNECTION_NAME
  | CONSTRAINT_CATALOG
  | CONSTRAINT_NAME
  | CONSTRAINT_SCHEMA
  | CONSTRAINTS
  | CONSTRUCTOR
  | CONTINUE
  | CURSOR_NAME
  | DATA
  | DATETIME_INTERVAL_CODE
  | DATETIME_INTERVAL_PRECISION
  | DEFAULTS
  | DEFERRABLE
  | DEFERRED
  | DEFINED
  | DEFINER
  | DEGREE
  | DEPTH
  | DERIVED
  | DESC
  | DESCRIBE_CATALOG
  | DESCRIBE_NAME
  | DESCRIBE_PROCEDURE_SPECIFIC_CATALOG
  | DESCRIBE_PROCEDURE_SPECIFIC_NAME
  | DESCRIBE_PROCEDURE_SPECIFIC_SCHEMA
  | DESCRIBE_SCHEMA
  | DESCRIPTOR
  | DIAGNOSTICS
  | DISPATCH
  | DOMAIN
  | DYNAMIC_FUNCTION
  | DYNAMIC_FUNCTION_CODE
  | ENCODING
  | ENFORCED
  | ERROR
  | EXCLUDE
  | EXCLUDING
  | EXPRESSION
  | FINAL
  | FINISH
  | FINISH_CATALOG
  | FINISH_NAME
  | FINISH_PROCEDURE_SPECIFIC_CATALOG
  | FINISH_PROCEDURE_SPECIFIC_NAME
  | FINISH_PROCEDURE_SPECIFIC_SCHEMA
  | FINISH_SCHEMA
  | FIRST
  | FLAG
  | FOLLOWING
  | FORMAT
  | FORTRAN
  | FOUND
  | FULFILL
  | FULFILL_CATALOG
  | FULFILL_NAME
  | FULFILL_PROCEDURE_SPECIFIC_CATALOG
  | FULFILL_PROCEDURE_SPECIFIC_NAME
  | FULFILL_PROCEDURE_SPECIFIC_SCHEMA
  | FULFILL_SCHEMA
  | G
  | GENERAL
  | GENERATED
  | GO
  | GOTO
  | GRANTED
  | HAS_PASS_THROUGH_COLUMNS
  | HAS_PASS_THRU_COLS
  | HIERARCHY
  | IGNORE
  | IMMEDIATE
  | IMMEDIATELY
  | IMPLEMENTATION
  | INCLUDING
  | INCREMENT
  | INITIALLY
  | INPUT
  | INSTANCE
  | INSTANTIABLE
  | INSTEAD
  | INVOKER
  | ISOLATION
  | IS_PRUNABLE
  | JSON
  | K
  | KEEP
  | KEY
  | KEYS
  | KEY_MEMBER
  | KEY_TYPE
  | LAST
  | LENGTH
  | LEVEL
  | LOCATOR
  | M
  | MAP
  | MATCHED
  | MAXVALUE
  | MESSAGE_LENGTH
  | MESSAGE_OCTET_LENGTH
  | MESSAGE_TEXT
  | MINVALUE
  | MORE
  | MUMPS
  | NAME
  | NAMES
  | NESTED
  | NESTING
  | NEXT
  | NFC
  | NFD
  | NFKC
  | NFKD
  | NORMALIZED
  | NULLABLE
  | NULLS
  | NUMBER
  | OBJECT
  | OCTETS
  | OPTION
  | OPTIONS
  | ORDERING
  | ORDINALITY
  | OTHERS
  | OUTPUT
  | OVERFLOW
  | OVERRIDING
  | P
  | PAD
  | PARAMETER_MODE
  | PARAMETER_NAME
  | PARAMETER_ORDINAL_POSITION
  | PARAMETER_SPECIFIC_CATALOG
  | PARAMETER_SPECIFIC_NAME
  | PARAMETER_SPECIFIC_SCHEMA
  | PARTIAL
  | PASCAL
  | PASS
  | PASSING
  | PAST
  | PATH
  | PLACING
  | PLAN
  | PLI
  | PRECEDING
  | PRESERVE
  | PRIOR
  | PRIVATE
  | PRIVATE_PARAMETERS
  | PRIVATE_PARAMS_S
  | PRIVILEGES
  | PRUNE
  | PUBLIC
  | QUOTES
  | READ
  | RELATIVE
  | REPEATABLE
  | RESPECT
  | RESTART
  | RESTRICT
  | RETURNED_CARDINALITY
  | RETURNED_LENGTH
  | RETURNED_OCTET_LENGTH
  | RETURNED_SQLSTATE
  | RETURNING
  | RETURNS_ONLY_PASS_THROUGH
  | RET_ONLY_PASS_THRU
  | ROLE
  | ROUTINE
  | ROUTINE_CATALOG
  | ROUTINE_NAME
  | ROUTINE_SCHEMA
  | ROW_COUNT
  | SCALAR
  | SCALE
  | SCHEMA
  | SCHEMA_NAME
  | SCOPE_CATALOG
  | SCOPE_NAME
  | SCOPE_SCHEMA
  | SECTION
  | SECURITY
  | SELF
  | SEQUENCE
  | SERIALIZABLE
  | SERVER_NAME
  | SESSION
  | SETS
  | SIMPLE
  | SIZE
  | SOURCE
  | SPACE
  | SPECIFIC_NAME
  | START_CATALOG
  | START_NAME
  | START_PROCEDURE_SPECIFIC_CATALOG
  | START_PROCEDURE_SPECIFIC_NAME
  | START_PROCEDURE_SPECIFIC_SCHEMA
  | START_SCHEMA
  | STATE
  | STATEMENT
  | STRING
  | STRUCTURE
  | STYLE
  | SUBCLASS_ORIGIN
  | T
  | TABLE_NAME
  | TABLE_SEMANTICS
  | TEMPORARY
  | THROUGH
  | TIES
  | TOP_LEVEL_COUNT
  | TRANSACTION
  | TRANSACTION_ACTIVE
  | TRANSACTIONS_COMMITTED
  | TRANSACTIONS_ROLLED_BACK
  | TRANSFORM
  | TRANSFORMS
  | TRIGGER_CATALOG
  | TRIGGER_NAME
  | TRIGGER_SCHEMA
  | TYPE
  | UNBOUNDED
  | UNCOMMITTED
  | UNCONDITIONAL
  | UNDER
  | UNNAMED
  | USAGE
  | USER_DEFINED_TYPE_CATALOG
  | USER_DEFINED_TYPE_CODE
  | USER_DEFINED_TYPE_NAME
  | USER_DEFINED_TYPE_SCHEMA
  | UTF16
  | UTF32
  | UTF8
  | VIEW
  | WORK
  | WRAPPER
  | WRITE
  | ZONE

<non-second primary datetime field> ::=
    YEAR
  | MONTH
  | DAY
  | HOUR
  | MINUTE

<nondelimiter token> ::=
    <regular identifier>
  | <key word>
  | <unsigned numeric literal>
  | <national character string literal>
  | <binary string literal>
  | <large object length token>
  | <Unicode delimited identifier>
  | <Unicode character string literal>
  | <SQL language identifier>

<nondoublequote character> ::=
    !! See the Syntax Rules.

<nonparenthesized value expression primary> ::=
    <unsigned value specification>
  | <column reference>
  | <set function specification>
  | <window function>
  | <nested window function>
  | <scalar subquery>
  | <case expression>
  | <cast specification>
  | <field reference>
  | <subtype treatment>
  | <method invocation>
  | <static method invocation>
  | <new specification>
  | <attribute or method reference>
  | <reference resolution>
  | <collection value constructor>
  | <array element reference>
  | <multiset element reference>
  | <next value expression>
  | <routine invocation>
  | <row pattern navigation operation>
  | <JSON value function>

<nonquote character> ::=
    !! See the Syntax Rules.

<normal form> ::=
    NFC
  | NFD
  | NFKC
  | NFKD

<normalize function> ::=
    NORMALIZE <left paren> <character value expression> 
    [ <comma> <normal form> [ <comma> <normalize function result length> ] ] 
    <right paren>

<normalize function result length> ::=
    <character length>
  | <character large object length>

<normalized predicate> ::=
    <row value predicand> <normalized predicate part 2>

<normalized predicate part 2> ::=
    IS [ NOT ] [ <normal form> ] NORMALIZED

<not equals operator> ::=
    <>

<nth row> ::=
    <simple value specification>
  | <dynamic parameter specification>

<nth value function> ::=
    NTH_VALUE <left paren> <value expression> <comma> <nth row> <right paren> 
    [ <from first or last> ] [ <null treatment> ]

<ntile function> ::=
    NTILE <left paren> <number of tiles> <right paren>

<null ordering> ::=
    NULLS FIRST
  | NULLS LAST

<null predicate> ::=
    <row value predicand> <null predicate part 2>

<null predicate part 2> ::=
    IS [ NOT ] NULL

<null specification> ::=
    NULL

<null treatment> ::=
    RESPECT NULLS
  | IGNORE NULLS

<null-call clause> ::=
    RETURNS NULL ON NULL INPUT
  | CALLED ON NULL INPUT

<number of conditions> ::=
    <simple value specification>

<number of tiles> ::=
    <simple value specification>
  | <dynamic parameter specification>

<numeric primary> ::=
    <value expression primary>
  | <numeric value function>

<numeric type> ::=
    <exact numeric type>
  | <approximate numeric type>
  | <decimal floating-point type>

<numeric value expression> ::=
    <term>
  | <numeric value expression> <plus sign> <term>
  | <numeric value expression> <minus sign> <term>

<numeric value expression base> ::=
    <numeric value expression>

<numeric value expression dividend> ::=
    <numeric value expression>

<numeric value expression divisor> ::=
    <numeric value expression>

<numeric value expression exponent> ::=
    <numeric value expression>

<numeric value function> ::=
    <position expression>
  | <regex occurrences function>
  | <regex position expression>
  | <extract expression>
  | <length expression>
  | <cardinality expression>
  | <max cardinality expression>
  | <absolute value expression>
  | <modulus expression>
  | <trigonometric function>
  | <general logarithm function>
  | <common logarithm>
  | <natural logarithm>
  | <exponential function>
  | <power function>
  | <square root>
  | <floor function>
  | <ceiling function>
  | <width bucket function>
  | <match number function>

<object column> ::=
    <column name>

<object name> ::=
    [ TABLE ] <table name>
  | DOMAIN <domain name>
  | COLLATION <collation name>
  | CHARACTER SET <character set name>
  | TRANSLATION <transliteration name>
  | TYPE <schema-resolved user-defined type name>
  | SEQUENCE <sequence generator name>
  | <specific routine designator>

<object privileges> ::=
    ALL PRIVILEGES
  | <action> [ { <comma> <action> }... ]

<occurrences> ::=
    <simple value specification>

<octet length expression> ::=
    OCTET_LENGTH <left paren> <string value expression> <right paren>

<octet like predicate> ::=
    <row value predicand> <octet like predicate part 2>

<octet like predicate part 2> ::=
    [ NOT ] LIKE <octet pattern> [ ESCAPE <escape octet> ]

<octet pattern> ::=
    <binary value expression>

<offset> ::=
    <exact numeric literal>

<offset row count> ::=
    <simple value specification>

<old transition table name> ::=
    <transition table name>

<old transition variable name> ::=
    <correlation name>

<only spec> ::=
    ONLY <left paren> <table or query name> <right paren>

<open statement> ::=
    OPEN <cursor name>

<order by clause> ::=
    ORDER BY <sort specification list>

<ordered set function> ::=
    <hypothetical set function>
  | <inverse distribution function>
  | <listagg set function>

<ordering category> ::=
    <relative category>
  | <map category>
  | <state category>

<ordering form> ::=
    <equals ordering form>
  | <full ordering form>

<ordering specification> ::=
    ASC
  | DESC

<ordinary grouping set> ::=
    <grouping column reference>
  | <left paren> <grouping column reference list> <right paren>

<ordinary grouping set list> ::=
    <ordinary grouping set> [ { <comma> <ordinary grouping set> }... ]

<original method specification> ::=
    <partial method specification> [ SELF AS RESULT ] [ SELF AS LOCATOR ] 
    [ <method characteristics> ]

<outer join type> ::=
    LEFT
  | RIGHT
  | FULL

<output using clause> ::=
    <into arguments>
  | <into descriptor>

<overflow behavior> ::=
    ERROR
  | TRUNCATE [ <listagg truncation filler> ] <listagg count indication>

<overlaps predicate> ::=
    <overlaps predicate part 1> <overlaps predicate part 2>

<overlaps predicate part 1> ::=
    <row value predicand 1>

<overlaps predicate part 2> ::=
    OVERLAPS <row value predicand 2>

<override clause> ::=
    OVERRIDING USER VALUE
  | OVERRIDING SYSTEM VALUE

<overriding method specification> ::=
    OVERRIDING <partial method specification>

<pad characteristic> ::=
    NO PAD
  | PAD SPACE

<parameter default> ::=
    <value expression>
  | <contextually typed value specification>
  | <descriptor value constructor>

<parameter mode> ::=
    IN
  | OUT
  | INOUT

<parameter style> ::=
    SQL
  | GENERAL

<parameter style clause> ::=
    PARAMETER STYLE <parameter style>

<parameter type> ::=
    <data type> [ <locator indication> ]
  | <generic table parameter type>
  | <descriptor parameter type>

<parameter using clause> ::=
    <input using clause>

<parenthesized boolean value expression> ::=
    <left paren> <boolean value expression> <right paren>

<parenthesized derived column list> ::=
    <left paren> <derived column list> <right paren>

<parenthesized joined table> ::=
    <left paren> <parenthesized joined table> <right paren>
  | <left paren> <joined table> <right paren>

<parenthesized value expression> ::=
    <left paren> <value expression> <right paren>

<partial method specification> ::=
    [ INSTANCE STATIC CONSTRUCTOR ] METHOD <method name> 
    <SQL parameter declaration list> <returns clause> 
    [ SPECIFIC <specific method name> ]

<partitioned join column reference> ::=
    <column reference>

<partitioned join column reference list> ::=
    <left paren> <partitioned join column reference> 
    [ { <comma> <partitioned join column reference> }... ] <right paren>

<partitioned join table> ::=
    <table factor> PARTITION BY <partitioned join column reference list>

<pass through option> ::=
    PASS THROUGH
  | NO PASS THROUGH

<path column> ::=
    <column name>

<path specification> ::=
    PATH <schema name list>

<path-resolved user-defined type name> ::=
    <user-defined type name>

<percent> ::=
    %

<period> ::=
    .

<period begin column name> ::=
    <column name>

<period contains predicate> ::=
    <period predicand 1> <period contains predicate part 2>

<period contains predicate part 2> ::=
    CONTAINS <period or point-in-time predicand>

<period end column name> ::=
    <column name>

<period end value> ::=
    <datetime value expression>

<period equals predicate> ::=
    <period predicand 1> <period equals predicate part 2>

<period equals predicate part 2> ::=
    EQUALS <period predicand 2>

<period immediately precedes predicate> ::=
    <period predicand 1> <period immediately precedes predicate part 2>

<period immediately precedes predicate part 2> ::=
    IMMEDIATELY PRECEDES <period predicand 2>

<period immediately succeeds predicate> ::=
    <period predicand 1> <period immediately succeeds predicate part 2>

<period immediately succeeds predicate part 2> ::=
    IMMEDIATELY SUCCEEDS <period predicand 2>

<period or point-in-time predicand> ::=
    <period predicand>
  | <datetime value expression>

<period overlaps predicate> ::=
    <period predicand 1> <period overlaps predicate part 2>

<period overlaps predicate part 2> ::=
    OVERLAPS <period predicand 2>

<period precedes predicate> ::=
    <period predicand 1> <period precedes predicate part 2>

<period precedes predicate part 2> ::=
    PRECEDES <period predicand 2>

<period predicand> ::=
    <period reference>
  | PERIOD <left paren> <period start value> <comma> <period end value> 
    <right paren>

<period predicand 1> ::=
    <period predicand>

<period predicand 2> ::=
    <period predicand>

<period predicate> ::=
    <period overlaps predicate>
  | <period equals predicate>
  | <period contains predicate>
  | <period precedes predicate>
  | <period succeeds predicate>
  | <period immediately precedes predicate>
  | <period immediately succeeds predicate>

<period reference> ::=
    <basic identifier chain>

<period start value> ::=
    <datetime value expression>

<period succeeds predicate> ::=
    <period predicand 1> <period succeeds predicate part 2>

<period succeeds predicate part 2> ::=
    SUCCEEDS <period predicand 2>

<physical offset> ::=
    <simple value specification>
  | <dynamic parameter specification>

<pipe row statement> ::=
    PIPE ROW <PTF descriptor name>

<plus sign> ::=
    +

<point in time> ::=
    <datetime value expression>

<point in time 1> ::=
    <point in time>

<point in time 2> ::=
    <point in time>

<polymorphic table function body> ::=
    [ <PTF private parameters> ] 
    [ DESCRIBE WITH <PTF describe component procedure> ] 
    [ START WITH <PTF start component procedure> ] FULFILL WITH 
    <PTF fulfill component procedure> 
    [ FINISH WITH <PTF finish component procedure> ]

<position expression> ::=
    <character position expression>
  | <binary position expression>

<power function> ::=
    POWER <left paren> <numeric value expression base> <comma> 
    <numeric value expression exponent> <right paren>

<precision> ::=
    <unsigned integer>

<predefined type> ::=
    <character string type> [ CHARACTER SET <character set specification> ] 
    [ <collate clause> ]
  | <national character string type> [ <collate clause> ]
  | <binary string type>
  | <numeric type>
  | <boolean type>
  | <datetime type>
  | <interval type>

<predicate> ::=
    <comparison predicate>
  | <between predicate>
  | <in predicate>
  | <like predicate>
  | <similar predicate>
  | <regex like predicate>
  | <null predicate>
  | <quantified comparison predicate>
  | <exists predicate>
  | <unique predicate>
  | <normalized predicate>
  | <match predicate>
  | <overlaps predicate>
  | <distinct predicate>
  | <member predicate>
  | <submultiset predicate>
  | <set predicate>
  | <type predicate>
  | <period predicate>
  | <JSON predicate>
  | <JSON exists predicate>

<preparable SQL control statement> ::=
    <SQL control statement>

<preparable SQL data statement> ::=
    <delete statement: searched>
  | <dynamic single row select statement>
  | <insert statement>
  | <dynamic select statement>
  | <update statement: searched>
  | <truncate table statement>
  | <merge statement>
  | <preparable dynamic delete statement: positioned>
  | <preparable dynamic update statement: positioned>
  | <hold locator statement>
  | <free locator statement>

<preparable SQL schema statement> ::=
    <SQL schema statement>

<preparable SQL session statement> ::=
    <SQL session statement>

<preparable SQL transaction statement> ::=
    <SQL transaction statement>

<preparable dynamic cursor name> ::=
    [ <scope option> ] <cursor name>

<preparable dynamic delete statement: positioned> ::=
    DELETE [ FROM <target table> ] WHERE CURRENT OF 
    <preparable dynamic cursor name>

<preparable dynamic update statement: positioned> ::=
    UPDATE [ <target table> ] SET <set clause list> WHERE CURRENT OF 
    <preparable dynamic cursor name>

<preparable implementation-defined statement> ::=
    !! See the Syntax Rules.

<preparable statement> ::=
    <preparable SQL data statement>
  | <preparable SQL schema statement>
  | <preparable SQL transaction statement>
  | <preparable SQL control statement>
  | <preparable SQL session statement>
  | <preparable implementation-defined statement>

<prepare statement> ::=
    PREPARE <SQL statement name> [ <attributes specification> ] FROM 
    <SQL statement variable>

<prev or next> ::=
    PREV
  | NEXT

<primary datetime field> ::=
    <non-second primary datetime field>
  | SECOND

<private parameter declaration list> ::=
    <left paren> 
    [ <SQL parameter declaration> [ { <comma> <SQL parameter declaration> }... ] ] 
    <right paren>

<privilege column list> ::=
    <column name list>

<privilege method list> ::=
    <specific routine designator> [ { <comma> <specific routine designator> }... ]

<privileges> ::=
    <object privileges> ON <object name>

<procedure name> ::=
    <identifier>

<qualified asterisk> ::=
    <asterisked identifier chain> <period> <asterisk>
  | <all fields reference>

<qualified identifier> ::=
    <identifier>

<qualified join> ::=
    { <table reference> <partitioned join table> } [ <join type> ] JOIN 
    { <table reference> <partitioned join table> } <join specification>

<quantified comparison predicate> ::=
    <row value predicand> <quantified comparison predicate part 2>

<quantified comparison predicate part 2> ::=
    <comp op> <quantifier> <table subquery>

<quantifier> ::=
    <all>
  | <some>

<query expression> ::=
    [ <with clause> ] <query expression body> [ <order by clause> ] 
    [ <result offset clause> ] [ <fetch first clause> ]

<query expression body> ::=
    <query term>
  | <query expression body> UNION [ ALL DISTINCT ] [ <corresponding spec> ] 
    <query term>
  | <query expression body> EXCEPT [ ALL DISTINCT ] [ <corresponding spec> ] 
    <query term>

<query name> ::=
    <identifier>

<query primary> ::=
    <simple table>
  | <left paren> <query expression body> [ <order by clause> ] 
    [ <result offset clause> ] [ <fetch first clause> ] <right paren>

<query specification> ::=
    SELECT [ <set quantifier> ] <select list> <table expression>

<query system time period specification> ::=
    FOR SYSTEM_TIME AS OF <point in time 1>
  | FOR SYSTEM_TIME BETWEEN [ ASYMMETRIC SYMMETRIC ] <point in time 1> AND 
    <point in time 2>
  | FOR SYSTEM_TIME FROM <point in time 1> TO <point in time 2>

<query term> ::=
    <query primary>
  | <query term> INTERSECT [ ALL DISTINCT ] [ <corresponding spec> ] 
    <query primary>

<question mark> ::=
    ?

<quote> ::=
    '

<quote symbol> ::=
    <quote> <quote>

<range variable> ::=
    <table name>
  | <query name>
  | <correlation name>

<rank function type> ::=
    RANK
  | DENSE_RANK
  | PERCENT_RANK
  | CUME_DIST

<recursive search order> ::=
    DEPTH FIRST BY <column name list>
  | BREADTH FIRST BY <column name list>

<reference generation> ::=
    SYSTEM GENERATED
  | USER GENERATED
  | DERIVED

<reference resolution> ::=
    DEREF <left paren> <reference value expression> <right paren>

<reference type> ::=
    REF <left paren> <referenced type> <right paren> [ <scope clause> ]

<reference type specification> ::=
    <user-defined representation>
  | <derived representation>
  | <system-generated representation>

<reference value expression> ::=
    <value expression primary>

<referenceable view specification> ::=
    OF <path-resolved user-defined type name> [ <subview clause> ] 
    [ <view element list> ]

<referenced column list> ::=
    <column name list>

<referenced period specification> ::=
    PERIOD <application time period name>

<referenced table and columns> ::=
    <table name> 
    [ <left paren> <referenced column list> [ <comma> <referenced period specification> ] <right paren> ]

<referenced type> ::=
    <path-resolved user-defined type name>

<references specification> ::=
    REFERENCES <referenced table and columns> [ MATCH <match type> ] 
    [ <referential triggered action> ]

<referencing column list> ::=
    <column name list>

<referencing period specification> ::=
    PERIOD <application time period name>

<referential action> ::=
    CASCADE
  | SET NULL
  | SET DEFAULT
  | RESTRICT
  | NO ACTION

<referential constraint definition> ::=
    FOREIGN KEY <left paren> <referencing column list> 
    [ <comma> <referencing period specification> ] <right paren> 
    <references specification>

<referential triggered action> ::=
    <update rule> [ <delete rule> ]
  | <delete rule> [ <update rule> ]

<regex capture group> ::=
    <numeric value expression>

<regex like predicate> ::=
    <row value predicand> <regex like predicate part 2>

<regex like predicate part 2> ::=
    [ NOT ] LIKE_REGEX <XQuery pattern> [ FLAG <XQuery option flag> ]

<regex occurrence> ::=
    <numeric value expression>

<regex occurrences function> ::=
    OCCURRENCES_REGEX <left paren> <XQuery pattern> [ FLAG <XQuery option flag> ] 
    IN <regex subject string> [ FROM <start position> ] 
    [ USING <char length units> ] <right paren>

<regex position expression> ::=
    POSITION_REGEX <left paren> [ <regex position start or after> ] 
    <XQuery pattern> [ FLAG <XQuery option flag> ] IN <regex subject string> 
    [ FROM <start position> ] [ USING <char length units> ] 
    [ OCCURRENCE <regex occurrence> ] [ GROUP <regex capture group> ] 
    <right paren>

<regex position start or after> ::=
    START
  | AFTER

<regex subject string> ::=
    <character value expression>

<regex substring function> ::=
    SUBSTRING_REGEX <left paren> <XQuery pattern> [ FLAG <XQuery option flag> ] IN 
    <regex subject string> [ FROM <start position> ] 
    [ USING <char length units> ] [ OCCURRENCE <regex occurrence> ] 
    [ GROUP <regex capture group> ] <right paren>

<regex transliteration> ::=
    TRANSLATE_REGEX <left paren> <XQuery pattern> [ FLAG <XQuery option flag> ] IN 
    <regex subject string> [ WITH <XQuery replacement string> ] 
    [ FROM <start position> ] [ USING <char length units> ] 
    [ OCCURRENCE <regex transliteration occurrence> ] <right paren>

<regex transliteration occurrence> ::=
    <regex occurrence>
  | ALL

<regular character set> ::=
    <underscore>
  | <left bracket> <character enumeration>... <right bracket>
  | <left bracket> <circumflex> <character enumeration>... <right bracket>
  | <left bracket> <character enumeration include>... <circumflex> 
    <character enumeration exclude>... <right bracket>

<regular character set identifier> ::=
    <identifier>

<regular expression> ::=
    <regular term>
  | <regular expression> <vertical bar> <regular term>

<regular expression substring function> ::=
    SUBSTRING <left paren> <character value expression> SIMILAR 
    <character value expression> ESCAPE <escape character> <right paren>

<regular factor> ::=
    <regular primary>
  | <regular primary> <asterisk>
  | <regular primary> <plus sign>
  | <regular primary> <question mark>
  | <regular primary> <repeat factor>

<regular identifier> ::=
    <identifier body>

<regular primary> ::=
    <character specifier>
  | <percent>
  | <regular character set>
  | <left paren> <regular expression> <right paren>

<regular term> ::=
    <regular factor>
  | <regular term> <regular factor>

<regular view specification> ::=
    [ <left paren> <view column list> <right paren> ]

<relative category> ::=
    RELATIVE WITH <relative function specification>

<relative function specification> ::=
    <specific routine designator>

<release savepoint statement> ::=
    RELEASE SAVEPOINT <savepoint specifier>

<repeat argument> ::=
    <numeric value expression>

<repeat factor> ::=
    <left brace> <low value> [ <upper limit> ] <right brace>

<repeatable clause> ::=
    REPEATABLE <left paren> <repeat argument> <right paren>

<representation> ::=
    <predefined type>
  | <collection type>
  | <member list>

<reserved word> ::=
    ABS
  | ACOS
  | ALL
  | ALLOCATE
  | ALTER
  | AND
  | ANY
  | ARE
  | ARRAY
  | ARRAY_AGG
  | ARRAY_MAX_CARDINALITY
  | AS
  | ASENSITIVE
  | ASIN
  | ASYMMETRIC
  | AT
  | ATAN
  | ATOMIC
  | AUTHORIZATION
  | AVG
  | BEGIN
  | BEGIN_FRAME
  | BEGIN_PARTITION
  | BETWEEN
  | BIGINT
  | BINARY
  | BLOB
  | BOOLEAN
  | BOTH
  | BY
  | CALL
  | CALLED
  | CARDINALITY
  | CASCADED
  | CASE
  | CAST
  | CEIL
  | CEILING
  | CHAR
  | CHAR_LENGTH
  | CHARACTER
  | CHARACTER_LENGTH
  | CHECK
  | CLASSIFIER
  | CLOB
  | CLOSE
  | COALESCE
  | COLLATE
  | COLLECT
  | COLUMN
  | COMMIT
  | CONDITION
  | CONNECT
  | CONSTRAINT
  | CONTAINS
  | CONVERT
  | COPY
  | CORR
  | CORRESPONDING
  | COS
  | COSH
  | COUNT
  | COVAR_POP
  | COVAR_SAMP
  | CREATE
  | CROSS
  | CUBE
  | CUME_DIST
  | CURRENT
  | CURRENT_CATALOG
  | CURRENT_DATE
  | CURRENT_DEFAULT_TRANSFORM_GROUP
  | CURRENT_PATH
  | CURRENT_ROLE
  | CURRENT_ROW
  | CURRENT_SCHEMA
  | CURRENT_TIME
  | CURRENT_TIMESTAMP
  | CURRENT_PATH
  | CURRENT_ROLE
  | CURRENT_TRANSFORM_GROUP_FOR_TYPE
  | CURRENT_USER
  | CURSOR
  | CYCLE
  | DATE
  | DAY
  | DEALLOCATE
  | DEC
  | DECIMAL
  | DECFLOAT
  | DECLARE
  | DEFAULT
  | DEFINE
  | DELETE
  | DENSE_RANK
  | DEREF
  | DESCRIBE
  | DETERMINISTIC
  | DISCONNECT
  | DISTINCT
  | DOUBLE
  | DROP
  | DYNAMIC
  | EACH
  | ELEMENT
  | ELSE
  | EMPTY
  | END
  | END_FRAME
  | END_PARTITION
  | END-EXEC
  | EQUALS
  | ESCAPE
  | EVERY
  | EXCEPT
  | EXEC
  | EXECUTE
  | EXISTS
  | EXP
  | EXTERNAL
  | EXTRACT
  | FALSE
  | FETCH
  | FILTER
  | FIRST_VALUE
  | FLOAT
  | FLOOR
  | FOR
  | FOREIGN
  | FRAME_ROW
  | FREE
  | FROM
  | FULL
  | FUNCTION
  | FUSION
  | GET
  | GLOBAL
  | GRANT
  | GROUP
  | GROUPING
  | GROUPS
  | HAVING
  | HOLD
  | HOUR
  | IDENTITY
  | IN
  | INDICATOR
  | INITIAL
  | INNER
  | INOUT
  | INSENSITIVE
  | INSERT
  | INT
  | INTEGER
  | INTERSECT
  | INTERSECTION
  | INTERVAL
  | INTO
  | IS
  | JOIN
  | JSON_ARRAY
  | JSON_ARRAYAGG
  | JSON_EXISTS
  | JSON_OBJECT
  | JSON_OBJECTAGG
  | JSON_QUERY
  | JSON_TABLE
  | JSON_TABLE_PRIMITIVE
  | JSON_VALUE
  | LAG
  | LANGUAGE
  | LARGE
  | LAST_VALUE
  | LATERAL
  | LEAD
  | LEADING
  | LEFT
  | LIKE
  | LIKE_REGEX
  | LISTAGG
  | LN
  | LOCAL
  | LOCALTIME
  | LOCALTIMESTAMP
  | LOG
  | LOG10
  | LOWER
  | MATCH
  | MATCH_NUMBER
  | MATCH_RECOGNIZE
  | MATCHES
  | MAX
  | MEMBER
  | MERGE
  | METHOD
  | MIN
  | MINUTE
  | MOD
  | MODIFIES
  | MODULE
  | MONTH
  | MULTISET
  | NATIONAL
  | NATURAL
  | NCHAR
  | NCLOB
  | NEW
  | NO
  | NONE
  | NORMALIZE
  | NOT
  | NTH_VALUE
  | NTILE
  | NULL
  | NULLIF
  | NUMERIC
  | OCTET_LENGTH
  | OCCURRENCES_REGEX
  | OF
  | OFFSET
  | OLD
  | OMIT
  | ON
  | ONE
  | ONLY
  | OPEN
  | OR
  | ORDER
  | OUT
  | OUTER
  | OVER
  | OVERLAPS
  | OVERLAY
  | PARAMETER
  | PARTITION
  | PATTERN
  | PER
  | PERCENT
  | PERCENT_RANK
  | PERCENTILE_CONT
  | PERCENTILE_DISC
  | PERIOD
  | PORTION
  | POSITION
  | POSITION_REGEX
  | POWER
  | PRECEDES
  | PRECISION
  | PREPARE
  | PRIMARY
  | PROCEDURE
  | PTF
  | RANGE
  | RANK
  | READS
  | REAL
  | RECURSIVE
  | REF
  | REFERENCES
  | REFERENCING
  | REGR_AVGX
  | REGR_AVGY
  | REGR_COUNT
  | REGR_INTERCEPT
  | REGR_R2
  | REGR_SLOPE
  | REGR_SXX
  | REGR_SXY
  | REGR_SYY
  | RELEASE
  | RESULT
  | RETURN
  | RETURNS
  | REVOKE
  | RIGHT
  | ROLLBACK
  | ROLLUP
  | ROW
  | ROW_NUMBER
  | ROWS
  | RUNNING
  | SAVEPOINT
  | SCOPE
  | SCROLL
  | SEARCH
  | SECOND
  | SEEK
  | SELECT
  | SENSITIVE
  | SESSION_USER
  | SET
  | SHOW
  | SIMILAR
  | SIN
  | SINH
  | SKIP
  | SMALLINT
  | SOME
  | SPECIFIC
  | SPECIFICTYPE
  | SQL
  | SQLEXCEPTION
  | SQLSTATE
  | SQLWARNING
  | SQRT
  | START
  | STATIC
  | STDDEV_POP
  | STDDEV_SAMP
  | SUBMULTISET
  | SUBSET
  | SUBSTRING
  | SUBSTRING_REGEX
  | SUCCEEDS
  | SUM
  | SYMMETRIC
  | SYSTEM
  | SYSTEM_TIME
  | SYSTEM_USER
  | TABLE
  | TABLESAMPLE
  | TAN
  | TANH
  | THEN
  | TIME
  | TIMESTAMP
  | TIMEZONE_HOUR
  | TIMEZONE_MINUTE
  | TO
  | TRAILING
  | TRANSLATE
  | TRANSLATE_REGEX
  | TRANSLATION
  | TREAT
  | TRIGGER
  | TRIM
  | TRIM_ARRAY
  | TRUE
  | TRUNCATE
  | UESCAPE
  | UNION
  | UNIQUE
  | UNKNOWN
  | UNNEST
  | UPDATE
  | UPPER
  | USER
  | USING
  | VALUE
  | VALUES
  | VALUE_OF
  | VAR_POP
  | VAR_SAMP
  | VARBINARY
  | VARCHAR
  | VARYING
  | VERSIONING
  | WHEN
  | WHENEVER
  | WHERE
  | WIDTH_BUCKET
  | WINDOW
  | WITH
  | WITHIN
  | WITHOUT
  | YEAR

<result> ::=
    <result expression>
  | NULL

<result cast> ::=
    CAST FROM <result cast from type>

<result cast from type> ::=
    <data type> [ <locator indication> ]

<result expression> ::=
    <value expression>

<result offset clause> ::=
    OFFSET <offset row count> { ROW ROWS }

<result option> ::=
    FINAL
  | NEW
  | OLD

<result using clause> ::=
    <output using clause>

<return statement> ::=
    RETURN <return value>

<return value> ::=
    <value expression>
  | NULL

<returned result sets characteristic> ::=
    DYNAMIC RESULT SETS <maximum returned result sets>

<returns clause> ::=
    RETURNS <returns type>

<returns data type> ::=
    <data type> [ <locator indication> ]

<returns table type> ::=
    TABLE [ <table function column list> ]
  | ONLY PASS THROUGH

<returns type> ::=
    <returns data type> [ <result cast> ]
  | <returns table type>

<reverse solidus> ::=
    \

<revoke option extension> ::=
    GRANT OPTION FOR
  | HIERARCHY OPTION FOR

<revoke privilege statement> ::=
    REVOKE [ <revoke option extension> ] <privileges> FROM <grantee> 
    [ { <comma> <grantee> }... ] [ GRANTED BY <grantor> ] <drop behavior>

<revoke role statement> ::=
    REVOKE [ ADMIN OPTION FOR ] <role revoked> [ { <comma> <role revoked> }... ] 
    FROM <grantee> [ { <comma> <grantee> }... ] [ GRANTED BY <grantor> ] 
    <drop behavior>

<revoke statement> ::=
    <revoke privilege statement>
  | <revoke role statement>

<right arrow> ::=
    ->

<right brace> ::=
    }

<right bracket> ::=
    ]

<right bracket or trigraph> ::=
    <right bracket>
  | <right bracket trigraph>

<right bracket trigraph> ::=
    ??)

<right minus brace> ::=
    -}

<right paren> ::=
    )

<rights clause> ::=
    SQL SECURITY INVOKER
  | SQL SECURITY DEFINER

<role definition> ::=
    CREATE ROLE <role name> [ WITH ADMIN <grantor> ]

<role granted> ::=
    <role name>

<role name> ::=
    <identifier>

<role revoked> ::=
    <role name>

<role specification> ::=
    <value specification>
  | NONE

<rollback statement> ::=
    ROLLBACK [ WORK ] [ AND [ NO ] CHAIN ] [ <savepoint clause> ]

<rollup list> ::=
    ROLLUP <left paren> <ordinary grouping set list> <right paren>

<routine body> ::=
    <SQL routine spec>
  | <external body reference>
  | <polymorphic table function body>

<routine characteristic> ::=
    <language clause>
  | <parameter style clause>
  | SPECIFIC <specific name>
  | <deterministic characteristic>
  | <SQL-data access indication>
  | <null-call clause>
  | <returned result sets characteristic>
  | <savepoint level indication>

<routine characteristics> ::=
    [ <routine characteristic>... ]

<routine invocation> ::=
    <routine name> <SQL argument list>

<routine name> ::=
    [ <schema name> <period> ] <qualified identifier>

<routine type> ::=
    ROUTINE
  | FUNCTION
  | PROCEDURE
  | [ INSTANCE STATIC CONSTRUCTOR ] METHOD

<row marker> ::=
    BEGIN_PARTITION
  | BEGIN_FRAME
  | CURRENT_ROW
  | FRAME_ROW
  | END_FRAME
  | END_PARTITION

<row marker delta> ::=
    <plus sign> <row marker offset>
  | <minus sign> <row marker offset>

<row marker expression> ::=
    <row marker> [ <row marker delta> ]

<row marker offset> ::=
    <simple value specification>
  | <dynamic parameter specification>

<row pattern> ::=
    <row pattern term>
  | <row pattern alternation>

<row pattern alternation> ::=
    <row pattern> <vertical bar> <row pattern term>

<row pattern common syntax> ::=
    [ AFTER MATCH <row pattern skip to> ] [ <row pattern initial or seek> ] 
    PATTERN <left paren> <row pattern> <right paren> 
    [ <row pattern subset clause> ] DEFINE <row pattern definition list>

<row pattern count function> ::=
    COUNT <left paren> <row pattern variable name> <period> <asterisk> 
    <right paren>

<row pattern definition> ::=
    <row pattern definition variable name> AS 
    <row pattern definition search condition>

<row pattern definition list> ::=
    <row pattern definition> [ { <comma> <row pattern definition> }... ]

<row pattern definition search condition> ::=
    <search condition>

<row pattern definition variable name> ::=
    <row pattern variable name>

<row pattern empty match handling> ::=
    SHOW EMPTY MATCHES
  | OMIT EMPTY MATCHES
  | WITH UNMATCHED ROWS

<row pattern factor> ::=
    <row pattern primary> [ <row pattern quantifier> ]

<row pattern initial or seek> ::=
    INITIAL
  | SEEK

<row pattern input derived column list> ::=
    <parenthesized derived column list>

<row pattern input name> ::=
    <correlation name>

<row pattern measure definition> ::=
    <row pattern measure expression> AS <measure name>

<row pattern measure expression> ::=
    <value expression>

<row pattern measure list> ::=
    <row pattern measure definition> 
    [ { <comma> <row pattern measure definition> }... ]

<row pattern measures> ::=
    MEASURES <row pattern measure list>

<row pattern navigation operation> ::=
    <row pattern navigation: logical>
  | <row pattern navigation: physical>
  | <row pattern navigation: compound>

<row pattern navigation: compound> ::=
    <prev or next> <left paren> [ <running or final> ] <first or last> 
    <left paren> <value expression> [ <comma> <logical offset> ] <right paren> 
    [ <comma> <physical offset> ] <right paren>

<row pattern navigation: logical> ::=
    [ <running or final> ] <first or last> <left paren> <value expression> 
    [ <comma> <logical offset> ] <right paren>

<row pattern navigation: physical> ::=
    <prev or next> <left paren> <value expression> [ <comma> <physical offset> ] 
    <right paren>

<row pattern order by> ::=
    ORDER BY <sort specification list>

<row pattern output derived column list> ::=
    <parenthesized derived column list>

<row pattern output name> ::=
    <correlation name>

<row pattern partition by> ::=
    PARTITION BY <row pattern partition list>

<row pattern partition column> ::=
    <column reference> [ <collate clause> ]

<row pattern partition list> ::=
    <row pattern partition column> 
    [ { <comma> <row pattern partition column> }... ]

<row pattern permute> ::=
    PERMUTE <left paren> <row pattern> [ { <comma> <row pattern> }... ] 
    <right paren>

<row pattern primary> ::=
    <row pattern primary variable name>
  | <dollar sign>
  | <circumflex>
  | <left paren> [ <row pattern> ] <right paren>
  | <left brace minus> <row pattern> <right minus brace>
  | <row pattern permute>

<row pattern primary variable name> ::=
    <row pattern variable name>

<row pattern quantifier> ::=
    <asterisk> [ <question mark> ]
  | <plus sign> [ <question mark> ]
  | <question mark> [ <question mark> ]
  | <left brace> [ <unsigned integer> ] <comma> [ <unsigned integer> ] 
    <right brace> [ <question mark> ]
  | <left brace> <unsigned integer> <right brace>

<row pattern recognition clause> ::=
    MATCH_RECOGNIZE <left paren> [ <row pattern partition by> ] 
    [ <row pattern order by> ] [ <row pattern measures> ] 
    [ <row pattern rows per match> ] <row pattern common syntax> <right paren>

<row pattern recognition clause and name> ::=
    [ [ AS ] <row pattern input name> [ <row pattern input derived column list> ] ] 
    <row pattern recognition clause> 
    [ [ AS ] <row pattern output name> [ <row pattern output derived column list> ] ]

<row pattern rows per match> ::=
    ONE ROW PER MATCH
  | ALL ROWS PER MATCH [ <row pattern empty match handling> ]

<row pattern skip to> ::=
    SKIP TO NEXT ROW
  | SKIP PAST LAST ROW
  | SKIP TO FIRST <row pattern skip to variable name>
  | SKIP TO LAST <row pattern skip to variable name>
  | SKIP TO <row pattern skip to variable name>

<row pattern skip to variable name> ::=
    <row pattern variable name>

<row pattern subset clause> ::=
    SUBSET <row pattern subset list>

<row pattern subset item> ::=
    <row pattern subset item variable name> <equals operator> <left paren> 
    <row pattern subset rhs> <right paren>

<row pattern subset item variable name> ::=
    <row pattern variable name>

<row pattern subset list> ::=
    <row pattern subset item> [ { <comma> <row pattern subset item> }... ]

<row pattern subset rhs> ::=
    <row pattern subset rhs variable name> 
    [ { <comma> <row pattern subset rhs variable name> }... ]

<row pattern subset rhs variable name> ::=
    <row pattern variable name>

<row pattern term> ::=
    <row pattern factor>
  | <row pattern term> <row pattern factor>

<row pattern variable name> ::=
    <correlation name>

<row subquery> ::=
    <subquery>

<row type> ::=
    ROW <row type body>

<row type body> ::=
    <left paren> <field definition> [ { <comma> <field definition> }... ] 
    <right paren>

<row value constructor> ::=
    <common value expression>
  | <boolean value expression>
  | <explicit row value constructor>

<row value constructor element> ::=
    <value expression>

<row value constructor element list> ::=
    <row value constructor element> 
    [ { <comma> <row value constructor element> }... ]

<row value constructor predicand> ::=
    <common value expression>
  | <boolean predicand>
  | <explicit row value constructor>

<row value expression> ::=
    <row value special case>
  | <explicit row value constructor>

<row value expression list> ::=
    <table row value expression> [ { <comma> <table row value expression> }... ]

<row value predicand> ::=
    <row value special case>
  | <row value constructor predicand>

<row value predicand 1> ::=
    <row value predicand>

<row value predicand 2> ::=
    <row value predicand>

<row value predicand 3> ::=
    <row value predicand>

<row value predicand 4> ::=
    <row value predicand>

<row value special case> ::=
    <nonparenthesized value expression primary>

<running or final> ::=
    RUNNING
  | FINAL

<sample clause> ::=
    TABLESAMPLE <sample method> <left paren> <sample percentage> <right paren> 
    [ <repeatable clause> ]

<sample method> ::=
    BERNOULLI
  | SYSTEM

<sample percentage> ::=
    <numeric value expression>

<savepoint clause> ::=
    TO SAVEPOINT <savepoint specifier>

<savepoint level indication> ::=
    NEW SAVEPOINT LEVEL
  | OLD SAVEPOINT LEVEL

<savepoint name> ::=
    <identifier>

<savepoint specifier> ::=
    <savepoint name>

<savepoint statement> ::=
    SAVEPOINT <savepoint specifier>

<scalar subquery> ::=
    <subquery>

<scale> ::=
    <unsigned integer>

<schema authorization identifier> ::=
    <authorization identifier>

<schema character set or path> ::=
    <schema character set specification>
  | <schema path specification>
  | <schema character set specification> <schema path specification>
  | <schema path specification> <schema character set specification>

<schema character set specification> ::=
    DEFAULT CHARACTER SET <character set specification>

<schema definition> ::=
    CREATE SCHEMA <schema name clause> [ <schema character set or path> ] 
    [ <schema element>... ]

<schema element> ::=
    <table definition>
  | <view definition>
  | <domain definition>
  | <character set definition>
  | <collation definition>
  | <transliteration definition>
  | <assertion definition>
  | <trigger definition>
  | <user-defined type definition>
  | <user-defined cast definition>
  | <user-defined ordering definition>
  | <transform definition>
  | <schema routine>
  | <sequence generator definition>
  | <grant statement>
  | <role definition>

<schema function> ::=
    CREATE <SQL-invoked function>

<schema name> ::=
    [ <catalog name> <period> ] <unqualified schema name>

<schema name characteristic> ::=
    SCHEMA <value specification>

<schema name clause> ::=
    <schema name>
  | AUTHORIZATION <schema authorization identifier>
  | <schema name> AUTHORIZATION <schema authorization identifier>

<schema name list> ::=
    <schema name> [ { <comma> <schema name> }... ]

<schema path specification> ::=
    <path specification>

<schema procedure> ::=
    CREATE <SQL-invoked procedure>

<schema qualified name> ::=
    [ <schema name> <period> ] <qualified identifier>

<schema qualified routine name> ::=
    <schema qualified name>

<schema routine> ::=
    <schema procedure>
  | <schema function>

<schema-resolved user-defined type name> ::=
    <user-defined type name>

<scope clause> ::=
    SCOPE <table name>

<scope option> ::=
    GLOBAL
  | LOCAL

<search clause> ::=
    SEARCH <recursive search order> SET <sequence column>

<search condition> ::=
    <boolean value expression>

<search or cycle clause> ::=
    <search clause>
  | <cycle clause>
  | <search clause> <cycle clause>

<searched case> ::=
    CASE <searched when clause>... [ <else clause> ] END

<searched when clause> ::=
    WHEN <search condition> THEN <result>

<seconds fraction> ::=
    <unsigned integer>

<seconds integer value> ::=
    <unsigned integer>

<seconds value> ::=
    <seconds integer value> [ <period> [ <seconds fraction> ] ]

<select list> ::=
    <asterisk>
  | <select sublist> [ { <comma> <select sublist> }... ]

<select statement: single row> ::=
    SELECT [ <set quantifier> ] <select list> INTO <select target list> 
    <table expression>

<select sublist> ::=
    <derived column>
  | <qualified asterisk>

<select target list> ::=
    <target specification> [ { <comma> <target specification> }... ]

<self-referencing column name> ::=
    <column name>

<self-referencing column specification> ::=
    REF IS <self-referencing column name> [ <reference generation> ]

<semicolon> ::=
    ;

<separator> ::=
    { <comment> <white space> }...

<sequence column> ::=
    <column name>

<sequence generator cycle option> ::=
    CYCLE
  | NO CYCLE

<sequence generator data type option> ::=
    AS <data type>

<sequence generator definition> ::=
    CREATE SEQUENCE <sequence generator name> [ <sequence generator options> ]

<sequence generator increment> ::=
    <signed numeric literal>

<sequence generator increment by option> ::=
    INCREMENT BY <sequence generator increment>

<sequence generator max value> ::=
    <signed numeric literal>

<sequence generator maxvalue option> ::=
    MAXVALUE <sequence generator max value>
  | NO MAXVALUE

<sequence generator min value> ::=
    <signed numeric literal>

<sequence generator minvalue option> ::=
    MINVALUE <sequence generator min value>
  | NO MINVALUE

<sequence generator name> ::=
    <schema qualified name>

<sequence generator option> ::=
    <sequence generator data type option>
  | <common sequence generator options>

<sequence generator options> ::=
    <sequence generator option>...

<sequence generator restart value> ::=
    <signed numeric literal>

<sequence generator start value> ::=
    <signed numeric literal>

<sequence generator start with option> ::=
    START WITH <sequence generator start value>

<session characteristic> ::=
    <session transaction characteristics>

<session characteristic list> ::=
    <session characteristic> [ { <comma> <session characteristic> }... ]

<session transaction characteristics> ::=
    TRANSACTION <transaction mode> [ { <comma> <transaction mode> }... ]

<set catalog statement> ::=
    SET <catalog name characteristic>

<set clause> ::=
    <multiple column assignment>
  | <set target> <equals operator> <update source>

<set clause list> ::=
    <set clause> [ { <comma> <set clause> }... ]

<set column default clause> ::=
    SET <default clause>

<set column not null clause> ::=
    SET NOT NULL

<set connection statement> ::=
    SET CONNECTION <connection object>

<set constraints mode statement> ::=
    SET CONSTRAINTS <constraint name list> { DEFERRED IMMEDIATE }

<set descriptor information> ::=
    <set header information> [ { <comma> <set header information> }... ]
  | VALUE <item number> <set item information> 
    [ { <comma> <set item information> }... ]

<set descriptor statement> ::=
    SET [ SQL ] DESCRIPTOR <descriptor name> <set descriptor information>

<set domain default clause> ::=
    SET <default clause>

<set function specification> ::=
    [ <running or final> ] <aggregate function>
  | <grouping operation>

<set function type> ::=
    <computational operation>

<set header information> ::=
    <header item name> <equals operator> <simple value specification 1>

<set identity column generation clause> ::=
    SET GENERATED { ALWAYS BY DEFAULT }

<set item information> ::=
    <descriptor item name> <equals operator> <simple value specification 2>

<set local time zone statement> ::=
    SET TIME ZONE <set time zone value>

<set names statement> ::=
    SET <character set name characteristic>

<set path statement> ::=
    SET <SQL-path characteristic>

<set predicate> ::=
    <row value predicand> <set predicate part 2>

<set predicate part 2> ::=
    IS [ NOT ] A SET

<set quantifier> ::=
    DISTINCT
  | ALL

<set role statement> ::=
    SET ROLE <role specification>

<set schema statement> ::=
    SET <schema name characteristic>

<set session characteristics statement> ::=
    SET SESSION CHARACTERISTICS AS <session characteristic list>

<set session collation statement> ::=
    SET COLLATION <collation specification> 
    [ FOR <character set specification list> ]
  | SET NO COLLATION [ FOR <character set specification list> ]

<set session user identifier statement> ::=
    SET SESSION AUTHORIZATION <value specification>

<set target> ::=
    <update target>
  | <mutated set clause>

<set target list> ::=
    <left paren> <set target> [ { <comma> <set target> }... ] <right paren>

<set time zone value> ::=
    <interval value expression>
  | LOCAL

<set transaction statement> ::=
    SET [ LOCAL ] TRANSACTION <transaction characteristics>

<set transform group statement> ::=
    SET <transform group characteristic>

<sign> ::=
    <plus sign>
  | <minus sign>

<signed integer> ::=
    [ <sign> ] <unsigned integer>

<signed numeric literal> ::=
    [ <sign> ] <unsigned numeric literal>

<similar pattern> ::=
    <character value expression>

<similar predicate> ::=
    <row value predicand> <similar predicate part 2>

<similar predicate part 2> ::=
    [ NOT ] SIMILAR TO <similar pattern> [ ESCAPE <escape character> ]

<simple Latin letter> ::=
    <simple Latin upper case letter>
  | <simple Latin lower case letter>

<simple Latin lower case letter> ::=
    a
  | b
  | c
  | d
  | e
  | f
  | g
  | h
  | i
  | j
  | k
  | l
  | m
  | n
  | o
  | p
  | q
  | r
  | s
  | t
  | u
  | v
  | w
  | x
  | y
  | z

<simple Latin upper case letter> ::=
    A
  | B
  | C
  | D
  | E
  | F
  | G
  | H
  | I
  | J
  | K
  | L
  | M
  | N
  | O
  | P
  | Q
  | R
  | S
  | T
  | U
  | V
  | W
  | X
  | Y
  | Z

<simple case> ::=
    CASE <case operand> <simple when clause>... [ <else clause> ] END

<simple comment> ::=
    <simple comment introducer> [ <comment character>... ] <newline>

<simple comment introducer> ::=
    <minus sign> <minus sign>

<simple table> ::=
    <query specification>
  | <table value constructor>
  | <explicit table>

<simple target specification> ::=
    <host parameter name>
  | <SQL parameter reference>
  | <column reference>
  | <embedded variable name>

<simple target specification 1> ::=
    <simple target specification>

<simple target specification 2> ::=
    <simple target specification>

<simple value specification> ::=
    <literal>
  | <host parameter name>
  | <SQL parameter reference>
  | <embedded variable name>

<simple value specification 1> ::=
    <simple value specification>

<simple value specification 2> ::=
    <simple value specification>

<simple when clause> ::=
    WHEN <when operand list> THEN <result>

<single datetime field> ::=
    <non-second primary datetime field> 
    [ <left paren> <interval leading field precision> <right paren> ]
  | SECOND 
    [ <left paren> <interval leading field precision> [ <comma> <interval fractional seconds precision> ] <right paren> ]

<single group specification> ::=
    <group name>

<solidus> ::=
    /

<some> ::=
    SOME
  | ANY

<sort key> ::=
    <value expression>

<sort specification> ::=
    <sort key> [ <ordering specification> ] [ <null ordering> ]

<sort specification list> ::=
    <sort specification> [ { <comma> <sort specification> }... ]

<source character set specification> ::=
    <character set specification>

<source data type> ::=
    <data type>

<source descriptor name> ::=
    <descriptor name>

<space> ::=
    !! See the Syntax Rules.

<specific method name> ::=
    [ <schema name> <period> ] <qualified identifier>

<specific method specification designator> ::=
    [ INSTANCE STATIC CONSTRUCTOR ] METHOD <method name> <data type list>

<specific name> ::=
    <schema qualified name>

<specific routine designator> ::=
    SPECIFIC <routine type> <specific name>
  | <routine type> <member name> [ FOR <schema-resolved user-defined type name> ]

<specific type method> ::=
    <user-defined type value expression> <period> SPECIFICTYPE 
    [ <left paren> <right paren> ]

<square root> ::=
    SQRT <left paren> <numeric value expression> <right paren>

<standard character set name> ::=
    <character set name>

<start field> ::=
    <non-second primary datetime field> 
    [ <left paren> <interval leading field precision> <right paren> ]

<start position> ::=
    <numeric value expression>

<start transaction statement> ::=
    START TRANSACTION [ <transaction characteristics> ]

<state category> ::=
    STATE [ <specific name> ]

<statement information> ::=
    <statement information item> [ { <comma> <statement information item> }... ]

<statement information item> ::=
    <simple target specification> <equals operator> 
    <statement information item name>

<statement information item name> ::=
    NUMBER
  | MORE
  | COMMAND_FUNCTION
  | COMMAND_FUNCTION_CODE
  | DYNAMIC_FUNCTION
  | DYNAMIC_FUNCTION_CODE
  | ROW_COUNT
  | TRANSACTIONS_COMMITTED
  | TRANSACTIONS_ROLLED_BACK
  | TRANSACTION_ACTIVE

<statement name> ::=
    <identifier>

<statement or declaration> ::=
    <declare cursor>
  | <dynamic declare cursor>
  | <temporary table declaration>
  | <embedded authorization declaration>
  | <embedded path specification>
  | <embedded transform group specification>
  | <embedded collation specification>
  | <embedded exception declaration>
  | <SQL procedure statement>

<static method invocation> ::=
    <path-resolved user-defined type name> <double colon> <method name> 
    [ <SQL argument list> ]

<static method selection> ::=
    <routine invocation>

<status parameter> ::=
    SQLSTATE

<string length> ::=
    <numeric value expression>

<string value expression> ::=
    <character value expression>
  | <binary value expression>

<string value function> ::=
    <character value function>
  | <binary value function>
  | <JSON value constructor>
  | <JSON query>

<submultiset predicate> ::=
    <row value predicand> <submultiset predicate part 2>

<submultiset predicate part 2> ::=
    [ NOT ] SUBMULTISET [ OF ] <multiset value expression>

<subquery> ::=
    <left paren> <query expression> <right paren>

<subtable clause> ::=
    UNDER <supertable clause>

<subtype clause> ::=
    UNDER <supertype name>

<subtype operand> ::=
    <value expression>

<subtype treatment> ::=
    TREAT <left paren> <subtype operand> AS <target subtype> <right paren>

<subview clause> ::=
    UNDER <table name>

<supertable clause> ::=
    <supertable name>

<supertable name> ::=
    <table name>

<supertype name> ::=
    <path-resolved user-defined type name>

<system or application time period specification> ::=
    <system time period specification>
  | <application time period specification>

<system time period end column specification> ::=
    <timestamp generation rule> AS ROW END

<system time period specification> ::=
    PERIOD FOR SYSTEM_TIME

<system time period start column specification> ::=
    <timestamp generation rule> AS ROW START

<system versioning clause> ::=
    SYSTEM VERSIONING

<system-generated representation> ::=
    REF IS SYSTEM GENERATED

<table argument> ::=
    <table argument proper> 
    [ [ AS ] <table argument correlation name> [ <table argument parenthesized derived column list> ] ] 
    [ <table argument partitioning> ] [ <table argument pruning> ] 
    [ <table argument ordering> ]

<table argument correlation name> ::=
    <correlation name>

<table argument ordering> ::=
    ORDER BY <table argument ordering list>

<table argument ordering column> ::=
    <column reference> [ <ordering specification> ] [ <null ordering> ]

<table argument ordering list> ::=
    <table argument ordering column>
  | <left paren> <table argument ordering column> 
    [ { <comma> <table argument ordering column> }... ] <right paren>

<table argument parenthesized derived column list> ::=
    <parenthesized derived column list>

<table argument partitioning> ::=
    PARTITION BY <table argument partitioning list>

<table argument partitioning list> ::=
    <column reference>
  | <left paren> [ <column reference> [ { <comma> <column reference> }... ] ] 
    <right paren>

<table argument proper> ::=
    TABLE <left paren> <table or query name> <right paren>
  | TABLE <table subquery>
  | <table function invocation>

<table argument pruning> ::=
    PRUNE WHEN EMPTY
  | KEEP WHEN EMPTY

<table commit action> ::=
    PRESERVE
  | DELETE

<table constraint> ::=
    <unique constraint definition>
  | <referential constraint definition>
  | <check constraint definition>

<table constraint definition> ::=
    [ <constraint name definition> ] <table constraint> 
    [ <constraint characteristics> ]

<table contents source> ::=
    <table element list>
  | <typed table clause>
  | <as subquery clause>

<table definition> ::=
    CREATE [ <table scope> ] TABLE <table name> <table contents source> 
    [ WITH <system versioning clause> ] 
    [ ON COMMIT <table commit action> ROWS ]

<table element> ::=
    <column definition>
  | <table period definition>
  | <table constraint definition>
  | <like clause>

<table element list> ::=
    <left paren> <table element> [ { <comma> <table element> }... ] <right paren>

<table expression> ::=
    <from clause> [ <where clause> ] [ <group by clause> ] [ <having clause> ] 
    [ <window clause> ]

<table factor> ::=
    <table primary> [ <sample clause> ]

<table function column list> ::=
    <left paren> <table function column list element> 
    [ { <comma> <table function column list element> }... ] <right paren>

<table function column list element> ::=
    <column name> <data type>

<table function derived table> ::=
    TABLE <left paren> <collection value expression> <right paren>

<table function invocation> ::=
    <routine invocation>

<table name> ::=
    <local or schema qualified name>

<table or query name> ::=
    <table name>
  | <transition table name>
  | <query name>

<table period definition> ::=
    <system or application time period specification> <left paren> 
    <period begin column name> <comma> <period end column name> <right paren>

<table primary> ::=
    <table or query name> [ <query system time period specification> ] 
    [ <correlation or recognition> ]
  | <derived table> <correlation or recognition>
  | <lateral derived table> <correlation or recognition>
  | <collection derived table> <correlation or recognition>
  | <table function derived table> <correlation or recognition>
  | <PTF derived table> [ <correlation or recognition> ]
  | <only spec> [ <correlation or recognition> ]
  | <data change delta table> [ <correlation or recognition> ]
  | <JSON table> <correlation or recognition>
  | <JSON table primitive> <correlation name>
  | <parenthesized joined table>

<table reference> ::=
    <table factor>
  | <joined table>

<table reference list> ::=
    <table reference> [ { <comma> <table reference> }... ]

<table row value expression> ::=
    <row value special case>
  | <row value constructor>

<table scope> ::=
    <global or local> TEMPORARY

<table subquery> ::=
    <subquery>

<table value constructor> ::=
    VALUES <row value expression list>

<table value constructor by query> ::=
    TABLE <table subquery>

<target array element specification> ::=
    <target array reference> <left bracket or trigraph> 
    <simple value specification> <right bracket or trigraph>

<target array reference> ::=
    <SQL parameter reference>
  | <column reference>

<target character set specification> ::=
    <character set specification>

<target data type> ::=
    <data type>

<target descriptor name> ::=
    <PTF descriptor name>

<target specification> ::=
    <host parameter specification>
  | <SQL parameter reference>
  | <column reference>
  | <target array element specification>
  | <dynamic parameter specification>
  | <embedded variable specification>

<target subtype> ::=
    <path-resolved user-defined type name>
  | <reference type>

<target table> ::=
    <table name>
  | ONLY <left paren> <table name> <right paren>

<temporary table declaration> ::=
    DECLARE LOCAL TEMPORARY TABLE <table name> <table element list> 
    [ ON COMMIT <table commit action> ROWS ]

<term> ::=
    <factor>
  | <term> <asterisk> <factor>
  | <term> <solidus> <factor>

<time fractional seconds precision> ::=
    <unsigned integer>

<time interval> ::=
    <hours value> [ <colon> <minutes value> [ <colon> <seconds value> ] ]
  | <minutes value> [ <colon> <seconds value> ]
  | <seconds value>

<time literal> ::=
    TIME <time string>

<time precision> ::=
    <time fractional seconds precision>

<time string> ::=
    <quote> <unquoted time string> <quote>

<time value> ::=
    <hours value> <colon> <minutes value> <colon> <seconds value>

<time zone> ::=
    AT <time zone specifier>

<time zone field> ::=
    TIMEZONE_HOUR
  | TIMEZONE_MINUTE

<time zone interval> ::=
    <sign> <hours value> <colon> <minutes value>

<time zone specifier> ::=
    LOCAL
  | TIME ZONE <interval primary>

<timestamp generation rule> ::=
    GENERATED ALWAYS

<timestamp literal> ::=
    TIMESTAMP <timestamp string>

<timestamp precision> ::=
    <time fractional seconds precision>

<timestamp string> ::=
    <quote> <unquoted timestamp string> <quote>

<to sql> ::=
    TO SQL WITH <to sql function>

<to sql function> ::=
    <specific routine designator>

<token> ::=
    <nondelimiter token>
  | <delimiter token>

<transaction access mode> ::=
    READ ONLY
  | READ WRITE

<transaction characteristics> ::=
    [ <transaction mode> [ { <comma> <transaction mode> }... ] ]

<transaction mode> ::=
    <isolation level>
  | <transaction access mode>
  | <diagnostics size>

<transcoding> ::=
    CONVERT <left paren> <character value expression> USING <transcoding name> 
    <right paren>

<transcoding name> ::=
    <schema qualified name>

<transform definition> ::=
    CREATE { TRANSFORM TRANSFORMS } FOR <schema-resolved user-defined type name> 
    <transform group>...

<transform element> ::=
    <to sql>
  | <from sql>

<transform element list> ::=
    <transform element> [ <comma> <transform element> ]

<transform group> ::=
    <group name> <left paren> <transform element list> <right paren>

<transform group characteristic> ::=
    DEFAULT TRANSFORM GROUP <value specification>
  | TRANSFORM GROUP FOR TYPE <path-resolved user-defined type name> 
    <value specification>

<transform group element> ::=
    <group name>

<transform group specification> ::=
    TRANSFORM GROUP 
    { <single group specification> <multiple group specification> }

<transform kind> ::=
    TO SQL
  | FROM SQL

<transforms to be dropped> ::=
    ALL
  | <transform group element>

<transition table name> ::=
    <identifier>

<transition table or variable> ::=
    OLD [ ROW ] [ AS ] <old transition variable name>
  | NEW [ ROW ] [ AS ] <new transition variable name>
  | OLD TABLE [ AS ] <old transition table name>
  | NEW TABLE [ AS ] <new transition table name>

<transition table or variable list> ::=
    <transition table or variable>...

<transliteration definition> ::=
    CREATE TRANSLATION <transliteration name> FOR 
    <source character set specification> TO 
    <target character set specification> FROM <transliteration source>

<transliteration name> ::=
    <schema qualified name>

<transliteration routine> ::=
    <specific routine designator>

<transliteration source> ::=
    <existing transliteration name>
  | <transliteration routine>

<trigger action time> ::=
    BEFORE
  | AFTER
  | INSTEAD OF

<trigger column list> ::=
    <column name list>

<trigger definition> ::=
    CREATE TRIGGER <trigger name> <trigger action time> <trigger event> ON 
    <table name> [ REFERENCING <transition table or variable list> ] 
    <triggered action>

<trigger event> ::=
    INSERT
  | DELETE
  | UPDATE [ OF <trigger column list> ]

<trigger name> ::=
    <schema qualified name>

<triggered SQL statement> ::=
    <SQL procedure statement>
  | BEGIN ATOMIC { <SQL procedure statement> <semicolon> }... END

<triggered action> ::=
    [ FOR EACH { ROW STATEMENT } ] [ <triggered when clause> ] 
    <triggered SQL statement>

<triggered when clause> ::=
    WHEN <left paren> <search condition> <right paren>

<trigonometric function> ::=
    <trigonometric function name> <left paren> <numeric value expression> 
    <right paren>

<trigonometric function name> ::=
    SIN
  | COS
  | TAN
  | SINH
  | COSH
  | TANH
  | ASIN
  | ACOS
  | ATAN

<trim array function> ::=
    TRIM_ARRAY <left paren> <array value expression> <comma> 
    <numeric value expression> <right paren>

<trim character> ::=
    <character value expression>

<trim function> ::=
    TRIM <left paren> <trim operands> <right paren>

<trim octet> ::=
    <binary value expression>

<trim operands> ::=
    [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source>

<trim source> ::=
    <character value expression>

<trim specification> ::=
    LEADING
  | TRAILING
  | BOTH

<truncate table statement> ::=
    TRUNCATE TABLE <target table> [ <identity column restart option> ]

<truth value> ::=
    TRUE
  | FALSE
  | UNKNOWN

<type list> ::=
    <user-defined type specification> 
    [ { <comma> <user-defined type specification> }... ]

<type predicate> ::=
    <row value predicand> <type predicate part 2>

<type predicate part 2> ::=
    IS [ NOT ] OF <left paren> <type list> <right paren>

<typed table clause> ::=
    OF <path-resolved user-defined type name> [ <subtable clause> ] 
    [ <typed table element list> ]

<typed table element> ::=
    <column options>
  | <table constraint definition>
  | <self-referencing column specification>

<typed table element list> ::=
    <left paren> <typed table element> [ { <comma> <typed table element> }... ] 
    <right paren>

<underscore> ::=
    _

<unique column list> ::=
    <column name list>

<unique constraint definition> ::=
    <unique specification> <left paren> <unique column list> 
    [ <comma> <without overlap specification> ] <right paren>
  | UNIQUE ( VALUE )

<unique predicate> ::=
    UNIQUE <table subquery>

<unique specification> ::=
    UNIQUE
  | PRIMARY KEY

<unqualified schema name> ::=
    <identifier>

<unquoted date string> ::=
    <date value>

<unquoted interval string> ::=
    [ <sign> ] { <year-month literal> <day-time literal> }

<unquoted time string> ::=
    <time value> [ <time zone interval> ]

<unquoted timestamp string> ::=
    <unquoted date string> <space> <unquoted time string>

<unsigned integer> ::=
    <digit>...

<unsigned literal> ::=
    <unsigned numeric literal>
  | <general literal>

<unsigned numeric literal> ::=
    <exact numeric literal>
  | <approximate numeric literal>

<unsigned value specification> ::=
    <unsigned literal>
  | <general value specification>

<updatability clause> ::=
    FOR { READ ONLY UPDATE [ OF <column name list> ] }

<update rule> ::=
    ON UPDATE <referential action>

<update source> ::=
    <value expression>
  | <contextually typed value specification>

<update statement: positioned> ::=
    UPDATE <target table> [ [ AS ] <correlation name> ] SET <set clause list> 
    WHERE CURRENT OF <cursor name>

<update statement: searched> ::=
    UPDATE <target table> 
    [ FOR PORTION OF <application time period name> FROM <point in time 1> TO <point in time 2> ] 
    [ [ AS ] <correlation name> ] SET <set clause list> 
    [ WHERE <search condition> ]

<update target> ::=
    <object column>
  | <object column> <left bracket or trigraph> <simple value specification> 
    <right bracket or trigraph>

<upper limit> ::=
    <comma> [ <high value> ]

<user identifier> ::=
    <identifier>

<user-defined cast definition> ::=
    CREATE CAST <left paren> <source data type> AS <target data type> 
    <right paren> WITH <cast function> [ AS ASSIGNMENT ]

<user-defined character set name> ::=
    <character set name>

<user-defined ordering definition> ::=
    CREATE ORDERING FOR <schema-resolved user-defined type name> <ordering form>

<user-defined representation> ::=
    REF USING <predefined type>

<user-defined type body> ::=
    <schema-resolved user-defined type name> [ <subtype clause> ] 
    [ AS <representation> ] [ <user-defined type option list> ] 
    [ <method specification list> ]

<user-defined type definition> ::=
    CREATE TYPE <user-defined type body>

<user-defined type name> ::=
    [ <schema name> <period> ] <qualified identifier>

<user-defined type option> ::=
    <instantiable clause>
  | <finality>
  | <reference type specification>
  | <cast to ref>
  | <cast to type>
  | <cast to distinct>
  | <cast to source>

<user-defined type option list> ::=
    <user-defined type option> [ <user-defined type option>... ]

<user-defined type specification> ::=
    <inclusive user-defined type specification>
  | <exclusive user-defined type specification>

<user-defined type value expression> ::=
    <value expression primary>

<using argument> ::=
    <general value specification>

<using arguments> ::=
    USING <using argument> [ { <comma> <using argument> }... ]

<using descriptor> ::=
    USING [ SQL ] DESCRIPTOR <descriptor name>

<using input descriptor> ::=
    <using descriptor>

<value expression> ::=
    <common value expression>
  | <boolean value expression>
  | <row value expression>

<value expression primary> ::=
    <parenthesized value expression>
  | <nonparenthesized value expression primary>

<value specification> ::=
    <literal>
  | <general value specification>

<value_of default value> ::=
    <value expression>

<value_of expression at row> ::=
    VALUE_OF <left paren> <value expression> AT <row marker expression> 
    [ <comma> <value_of default value> ] <right paren>

<vertical bar> ::=
    |

<view column list> ::=
    <column name list>

<view column option> ::=
    <column name> WITH OPTIONS <scope clause>

<view definition> ::=
    CREATE [ RECURSIVE ] VIEW <table name> <view specification> AS 
    <query expression> [ WITH [ <levels clause> ] CHECK OPTION ]

<view element> ::=
    <self-referencing column specification>
  | <view column option>

<view element list> ::=
    <left paren> <view element> [ { <comma> <view element> }... ] <right paren>

<view specification> ::=
    <regular view specification>
  | <referenceable view specification>

<when operand> ::=
    <row value predicand>
  | <comparison predicate part 2>
  | <between predicate part 2>
  | <in predicate part 2>
  | <character like predicate part 2>
  | <octet like predicate part 2>
  | <similar predicate part 2>
  | <regex like predicate part 2>
  | <null predicate part 2>
  | <quantified comparison predicate part 2>
  | <normalized predicate part 2>
  | <match predicate part 2>
  | <overlaps predicate part 2>
  | <distinct predicate part 2>
  | <member predicate part 2>
  | <submultiset predicate part 2>
  | <set predicate part 2>
  | <type predicate part 2>

<when operand list> ::=
    <when operand> [ { <comma> <when operand> }... ]

<where clause> ::=
    WHERE <search condition>

<white space> ::=
    !! See the Syntax Rules.

<width bucket bound 1> ::=
    <numeric value expression>

<width bucket bound 2> ::=
    <numeric value expression>

<width bucket count> ::=
    <numeric value expression>

<width bucket function> ::=
    WIDTH_BUCKET <left paren> <width bucket operand> <comma> 
    <width bucket bound 1> <comma> <width bucket bound 2> <comma> 
    <width bucket count> <right paren>

<width bucket operand> ::=
    <numeric value expression>

<window clause> ::=
    WINDOW <window definition list>

<window definition> ::=
    <new window name> AS <window specification>

<window definition list> ::=
    <window definition> [ { <comma> <window definition> }... ]

<window frame between> ::=
    BETWEEN <window frame bound 1> AND <window frame bound 2>

<window frame bound> ::=
    <window frame start>
  | UNBOUNDED FOLLOWING
  | <window frame following>

<window frame bound 1> ::=
    <window frame bound>

<window frame bound 2> ::=
    <window frame bound>

<window frame clause> ::=
    [ <row pattern measures> ] <window frame units> <window frame extent> 
    [ <window frame exclusion> ] [ <row pattern common syntax> ]

<window frame exclusion> ::=
    EXCLUDE CURRENT ROW
  | EXCLUDE GROUP
  | EXCLUDE TIES
  | EXCLUDE NO OTHERS

<window frame extent> ::=
    <window frame start>
  | <window frame between>

<window frame following> ::=
    <unsigned value specification> FOLLOWING

<window frame preceding> ::=
    <unsigned value specification> PRECEDING

<window frame start> ::=
    UNBOUNDED PRECEDING
  | <window frame preceding>
  | CURRENT ROW

<window frame units> ::=
    ROWS
  | RANGE
  | GROUPS

<window function> ::=
    <window function type> OVER <window name or specification>

<window function type> ::=
    <rank function type> <left paren> <right paren>
  | ROW_NUMBER <left paren> <right paren>
  | <aggregate function>
  | <ntile function>
  | <lead or lag function>
  | <first or last value function>
  | <nth value function>
  | <window row pattern measure>

<window name> ::=
    <identifier>

<window name or specification> ::=
    <window name>
  | <in-line window specification>

<window order clause> ::=
    ORDER BY <sort specification list>

<window partition clause> ::=
    PARTITION BY <window partition column reference list>

<window partition column reference> ::=
    <column reference> [ <collate clause> ]

<window partition column reference list> ::=
    <window partition column reference> 
    [ { <comma> <window partition column reference> }... ]

<window row pattern measure> ::=
    <measure name>

<window specification> ::=
    <left paren> <window specification details> <right paren>

<window specification details> ::=
    [ <existing window name> ] [ <window partition clause> ] 
    [ <window order clause> ] [ <window frame clause> ]

<with clause> ::=
    WITH [ RECURSIVE ] <with list>

<with column list> ::=
    <column name list>

<with list> ::=
    <with list element> [ { <comma> <with list element> }... ]

<with list element> ::=
    <query name> [ <left paren> <with column list> <right paren> ] AS 
    <table subquery> [ <search or cycle clause> ]

<with or without data> ::=
    WITH NO DATA
  | WITH DATA

<with or without time zone> ::=
    WITH TIME ZONE
  | WITHOUT TIME ZONE

<within group specification> ::=
    WITHIN GROUP <left paren> ORDER BY <sort specification list> <right paren>

<without overlap specification> ::=
    <application time period name> WITHOUT OVERLAPS

<year-month literal> ::=
    <years value> [ <minus sign> <months value> ]
  | <months value>

<years value> ::=
    <datetime value>
